'use strict';

function Arg1() {
    return {
        type: 'Arg1'
    };
};
function Array(elements) {
    return {
        type: 'Array',
        elements
    };
};
function Assertion(assertion, negation = false) {
    return {
        type: 'Assertion',
        negation,
        assertion
    };
};
function Binary(operator, left, right) {
    return {
        type: 'Binary',
        operator,
        left,
        right
    };
};
function Block(definitions, body) {
    return {
        type: 'Block',
        definitions,
        body
    };
};
function Compare(query, order) {
    return {
        type: 'Compare',
        query,
        order
    };
};
function CompareFunction(compares) {
    return {
        type: 'CompareFunction',
        compares
    };
};
function Conditional(test, consequent, alternate) {
    return {
        type: 'Conditional',
        test,
        consequent,
        alternate
    };
};
function Context() {
    return {
        type: 'Context'
    };
};
function Current() {
    return {
        type: 'Current'
    };
};
function Data() {
    return {
        type: 'Data'
    };
};
function Declarator(name) {
    return {
        type: 'Declarator',
        name
    };
};
function Definition(declarator, value) {
    return {
        type: 'Definition',
        declarator,
        value
    };
};
function Filter(value, query) {
    return {
        type: 'Filter',
        value,
        query
    };
};
function Function(args, body, legacy) {
    return {
        type: 'Function',
        arguments: args,
        body,
        legacy: Boolean(legacy)
    };
};
function GetProperty(value, property) {
    return {
        type: 'GetProperty',
        value,
        property
    };
};
function Identifier(name) {
    return {
        type: 'Identifier',
        name
    };
};
function Literal(value) {
    return {
        type: 'Literal',
        value
    };
};
function Map(value, query) {
    return {
        type: 'Map',
        value,
        query
    };
};
function MapRecursive(value, query) {
    return {
        type: 'MapRecursive',
        value,
        query
    };
};
function Method(reference, args) {
    return {
        type: 'Method',
        reference,
        arguments: args
    };
};
function MethodCall(value, method) {
    return {
        type: 'MethodCall',
        value,
        method
    };
};
function Object$1(properties) {
    return {
        type: 'Object',
        properties
    };
};
function ObjectEntry(key, value) {
    return {
        type: 'ObjectEntry',
        key,
        value
    };
};
function Parentheses(body) {
    return {
        type: 'Parentheses',
        body
    };
};
function Pick(value, getter) {
    return {
        type: 'Pick',
        value,
        getter
    };
};
function Pipeline(left, right) {
    return {
        type: 'Pipeline',
        left,
        right
    };
};
function Placeholder() {
    return {
        type: 'Placeholder'
    };
};
function Postfix(argument, operator) {
    return {
        type: 'Postfix',
        operator,
        argument
    };
};
function Prefix(operator, argument) {
    return {
        type: 'Prefix',
        operator,
        argument
    };
};
function Reference(name) {
    return {
        type: 'Reference',
        name
    };
};
function SliceNotation(value, args) {
    return {
        type: 'SliceNotation',
        value,
        arguments: args
    };
};
function Spread(query, array = false) {
    return {
        type: 'Spread',
        query,
        array
    };
};
function Template(values) {
    return {
        type: 'Template',
        values
    };
};

exports.Arg1 = Arg1;
exports.Array = Array;
exports.Assertion = Assertion;
exports.Binary = Binary;
exports.Block = Block;
exports.Compare = Compare;
exports.CompareFunction = CompareFunction;
exports.Conditional = Conditional;
exports.Context = Context;
exports.Current = Current;
exports.Data = Data;
exports.Declarator = Declarator;
exports.Definition = Definition;
exports.Filter = Filter;
exports.Function = Function;
exports.GetProperty = GetProperty;
exports.Identifier = Identifier;
exports.Literal = Literal;
exports.Map = Map;
exports.MapRecursive = MapRecursive;
exports.Method = Method;
exports.MethodCall = MethodCall;
exports.Object = Object$1;
exports.ObjectEntry = ObjectEntry;
exports.Parentheses = Parentheses;
exports.Pick = Pick;
exports.Pipeline = Pipeline;
exports.Placeholder = Placeholder;
exports.Postfix = Postfix;
exports.Prefix = Prefix;
exports.Reference = Reference;
exports.SliceNotation = SliceNotation;
exports.Spread = Spread;
exports.Template = Template;
