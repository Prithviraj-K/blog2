'use strict';

/* parser generated by jison 0.4.18-remastered.7 */

const lexer = (function(){
/* Lexer generated by jison 0.4.18-remastered.7 */
const lexer = {
yy:{},
options: {"ranges":true},
rules: [/^(?:\/\/.*?(?:\n|\r\n?|\u2028|\u2029|$)|\/\*(?:.|\s)*?(?:\*\/|$))/,/^\s+/,/^\//,/^<(?!=)/,/^/,(input, state) => {
    if (input[0] !== (state === 'template' ? '}' : '`')) {
        return null;
    }

    for (let i = 1; i < input.length; i++) {
        if (input[i] === '`') {
            return i + 1;
        }

        if (input[i] === '$' && input[i + 1] === '{') {
            return i + 2;
        }

        if (input[i] === '\\') {
            i++;
        }
    }

    return null;
},(input, state) => {
    if (input[0] !== (state === 'template' ? '}' : '`')) {
        return null;
    }

    for (let i = 1; i < input.length; i++) {
        if (input[i] === '`') {
            return i + 1;
        }

        if (input[i] === '$' && input[i + 1] === '{') {
            return i + 2;
        }

        if (input[i] === '\\') {
            i++;
        }
    }

    return null;
},/^/,/^\(/,/^\)/,/^\[/,/^\]/,/^\{/,/^\}/,/^(?:(true|false|null|undefined|Infinity|NaN)\b)/,/^and\b/,/^or\b/,/^has\s+no\b/,/^has\b/,/^in\b/,/^not\s+in\b/,/^not\b/,/^no\b/,/^(?:(asc|desc)(NA?|AN?)?\b)/,/^is\b/,/^if\b/,/^then\b/,/^else\b/,/^(?:(\d+\.|\.)?\d+([eE][-+]?\d+)?\b)/,/^0[xX][0-9a-fA-F]+/,/^(?:"(?:\\[\\"]|[^"])*")/,/^(?:'(?:\\[\\']|[^'])*')/,/^(?:\/(?:\\.|[^/])+\/[gimsu]*)/,/^(?:(?:[a-zA-Z_]|\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*)/,/^(?:\$(?:[a-zA-Z_]|\\u[0-9a-fA-F]{4})(?:[a-zA-Z_$0-9]|\\u[0-9a-fA-F]{4})*)/,/^@/,/^#/,/^\$\$/,/^\$/,/^=>/,/^<(?!=)/,/^=/,/^!=/,/^~=/,/^>=/,/^<=/,/^</,/^>/,/^\.\.\(/,/^\.\(/,/^\.\[/,/^\.\.\./,/^\.\./,/^\./,/^\?\?/,/^\?/,/^,/,/^:/,/^;/,/^\-/,/^\+/,/^\*/,/^\//,/^\%/,/^(?:\|)/,/^./,/^$/],
conditions: {"preventPrimitive":{"rules":[0,1,2,3,4,5,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66],"inclusive":true},"template":{"rules":[6,7],"inclusive":false},"INITIAL":{"rules":[0,1,5,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66],"inclusive":true}},
performAction(yy,yy_,__lexelActionId,YY_START) {

const YYSTATE=YY_START;
switch (__lexelActionId) {
case 0:{yy.commentRanges.push(yy_.yylloc.range);
break;}
case 1:{
break;}
case 2:{this.popState(); return 39;
break;}
case 3:{this.popState(); return 43;
break;}
case 4:{this.done = false;
            this.popState();
break;}
case 5:{const token = yy_.yytext.endsWith('`') ? 'TEMPLATE' : 'TPL_START';
            yy_.yytext = this.toStringLiteral(yy_.yytext, true, 1 + Number(token !== 'TEMPLATE'));
            if (token === 'TEMPLATE') {
                yy.pps();
            }
            return token;
break;}
case 6:{const token = yy_.yytext.endsWith('`') ? 'TPL_END' : 'TPL_CONTINUE';
            yy_.yytext = this.toStringLiteral(yy_.yytext, true, 1 + Number(token !== 'TPL_END'));
            this.popState();
            if (token === 'TPL_END') {
                yy.pps();
            }
            return token;
break;}
case 7:{this.parseError('Unexpected end of input');
break;}
case 8:{return 64;
break;}
case 9:{yy.pps(); return 65;
break;}
case 10:{return 60;
break;}
case 11:{yy.pps(); return 62;
break;}
case 12:{return 82;
break;}
case 13:{if (this.bracketStack[this.bracketStack.length - 1] !== 'TPL_END') {
                yy.pps();
                return 83;
            }

            this.unput('}');
            this.begin('template');
break;}
case 14:{yy_.yytext = this.toLiteral(yy_.yytext); // eslint-disable-line no-unused-vars
            return 56;
break;}
case 15:{return 35;
break;}
case 16:{return 36;
break;}
case 17:{return 34;
break;}
case 18:{return 32;
break;}
case 19:{return 31;
break;}
case 20:{return 33;
break;}
case 21:{return 25;
break;}
case 22:{return 26;
break;}
case 23:{return 92;
break;}
case 24:{return 29;
break;}
case 25:{return "IF";
break;}
case 26:{return "THEN";
break;}
case 27:{return "ELSE";
break;}
case 28:{yy.pps(); yy_.yytext = Number(yy_.yytext); return 54;
break;}
case 29:{yy.pps(); yy_.yytext = parseInt(yy_.yytext, 16); return 54;
break;}
case 30:{yy.pps(); yy_.yytext = this.toStringLiteral(yy_.yytext); return 53;
break;}
case 31:{yy.pps(); yy_.yytext = this.toStringLiteral(yy_.yytext); return 53;
break;}
case 32:{yy.pps(); yy_.yytext = this.toRegExp(yy_.yytext); return 55;
break;}
case 33:{yy.pps(); yy_.yytext = this.ident(yy_.yytext); return 14;
break;}
case 34:{yy.pps(); yy_.yytext = this.ident(yy_.yytext.slice(1)); return 15;
break;}
case 35:{yy.pps(); return 50;
break;}
case 36:{yy.pps(); return 51;
break;}
case 37:{yy.pps(); return 52;
break;}
case 38:{yy.pps(); return 9;
break;}
case 39:{return 22;
break;}
case 40:{this.fnOpened++;
            return 20;
break;}
case 41:{return 41;
break;}
case 42:{return 42;
break;}
case 43:{return 47;
break;}
case 44:{return 46;
break;}
case 45:{return 44;
break;}
case 46:{return 43;
break;}
case 47:{if (this.fnOpened) {
                this.fnOpened--;
                return 21;
            }
            return 45;
break;}
case 48:{return 70;
break;}
case 49:{return 67;
break;}
case 50:{return 68;
break;}
case 51:{return 86;
break;}
case 52:{yy.pps(); return 69;
break;}
case 53:{yy.pps(); return 66;
break;}
case 54:{return 37;
break;}
case 55:{return 17;
break;}
case 56:{return 72;
break;}
case 57:{return 11;
break;}
case 58:{return 10;
break;}
case 59:{return 27;
break;}
case 60:{return 28;
break;}
case 61:{return 38;
break;}
case 62:{return 39;
break;}
case 63:{return 40;
break;}
case 64:{return 24;
break;}
case 65:{this.parseError(`Bad input on line ${yy_.yylloc.first_line} column ${yy_.yylloc.first_column}\n` + this.showPosition(), {
                text: yy_.yytext,
                token: 'BAD_TOKEN'
            });
break;}
case 66:{return 5;
break;}
}
},
    setInput(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = false;
        this._backtrack = false;
        this.done = false;
        this.currentCondition = 'INITIAL';
        this.conditionStack = ['INITIAL'];
        this.offset = 0;
        this.yytext = this.match = '';
        this.yyleng = 0;
        this.yylineno = 0;
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };

        if (true) {
            this.yylloc.range = [0, 0];
        }

        return this;
    },
    parseError(str, details) {
        if (!this.yy.parser) {
            throw new Error(str);
        }

        this.yy.parser.parseError(str, details);
    },
    input() {
        const ch = this._input[this.offset];
        const newline = /\n|\r\n?|\u2028|\u2029/g.test(ch);

        this.offset++;
        this.yyleng++;
        this.yytext = this.match = this.yytext + ch;

        if (newline) {
            this.yylineno++;
            this.yylloc.last_line++;
            this.yylloc.last_column = 0;
        } else {
            this.yylloc.last_column++;
        }

        if (true) {
            this.yylloc.range[1]++;
        }

        return ch;
    },
    lineColumnForOffset(offset = this.offset, str = this._input, startLine = 1, startColumn = 0) {
        const rx = /\n|\r\n?|\u2028|\u2029/g;
        let line = startLine;
        let column = startColumn;
        let prevLastIndex = 0;
        let match;

        while ((match = rx.exec(str)) !== null) {
            if (match.index < offset) {
                line++;
                column = 0;
                prevLastIndex = match.index + match[0].length;
            } else {
                column += offset - prevLastIndex;
                prevLastIndex = -1;
                break;
            }
        }

        if (prevLastIndex !== -1) {
            column += offset - prevLastIndex;
        }

        return {
            line,
            column
        };
    },
    setMatch(start, end) {
        const newMatch = this._input.slice(start, end);
        const firstLoc = start !== this.offset ? this.lineColumnForOffset(start) : {
            line: this.yylloc.last_line,
            column: this.yylloc.last_column
        };
        const lastLoc = start !== end
            ? this.lineColumnForOffset(end - start, newMatch, firstLoc.line, firstLoc.column)
            : firstLoc;

        this.yytext = this.match = newMatch;
        this.yyleng = end - start;
        this.offset = end;

        this.yylineno = lastLoc.line - 1;
        this.yylloc = {
            first_line: firstLoc.line,
            first_column: firstLoc.column,
            last_line: lastLoc.line,
            last_column: lastLoc.column
        };

        if (true) {
            this.yylloc.range = [start, end];
        }
    },
    less(n) {
        const start = this.offset - this.match.length;

        this.setMatch(start, start + n);
    },
    unput(chunk) {
        const newMatchLength = this.match.length - chunk.length;

        if (!this.match.startsWith(chunk, newMatchLength)) {
            throw new Error('Lexer#unput() should receive a part of matched text only');
        }

        this.less(newMatchLength);
    },
    more() {
        this._more = true;
    },
    reject() {
        if (false) {
            this._backtrack = true;
            return;
        }

        // FIXME: remove method when options.backtrack_lexer is false
        throw new Error('reject() is allowed only when options.backtrack_lexer = true');
    },
    showPosition(offset = this.offset - this.match.length) {
        const input = this._input;
        const start = Math.max(offset - 20, 0);
        const end = Math.min(offset + 20, input.length);
        const pre = (start === 0 ? '' : '...') + input.slice(start, offset).replace(/\n|\r\n?|\u2028|\u2029/g, '\\n');
        const post = input.slice(offset, end).replace(/\n|\r\n?|\u2028|\u2029/g, '\\n') + (end === input.length ? '' : '...');

        return (
            pre +
            post +
            `\n${'-'.repeat(pre.length)}^`
        );
    },
    test_match(match, rule) {
        let backup;

        if (false) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylloc.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };

            if (true) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        this._more = false;
        this._backtrack = false;
        this.setMatch(this.offset, this.offset + match[0].length);
        this.matches = match;

        // perform action
        const token = this.performAction.call(
            this,
            this.yy,
            this,
            rule,
            this.conditionStack[this.conditionStack.length - 1]
        );

        if (!token && this._backtrack) {
            // recover context
            Object.assign(this, backup);

            return false; // rule action called reject() implying the next rule should be tested instead.
        }

        if (!this.eof()) {
            this.done = false;
        }

        if (typeof token === 'number' && this.yy.parser) {
            return this.yy.parser.terminals_[token];
        }

        return token || false;
    },
    eof() {
        return this.offset === this._input.length;
    },
    next() {
        if (this.done) {
            return 1; // EOF
        }

        if (this.eof()) {
            this.done = true;
        }

        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }

        let match;
        let matchRuleId;

        for (const ruleId of this.conditions[this.currentCondition].rules) {
            const rule = this.rules[ruleId];
            const ruleInput = this._input.slice(this.offset);
            let tempMatch;

            if (typeof rule === 'function') {
                const ret = rule(ruleInput, this.currentCondition);

                switch (typeof ret) {
                    case 'string': tempMatch = [ret]; break;
                    case 'number': tempMatch = [ruleInput.slice(0, ret)]; break;
                    default: tempMatch = ret;
                }
            } else {
                tempMatch = ruleInput.match(rule);
            }

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                matchRuleId = ruleId;

                if (false) {
                    const token = this.test_match(tempMatch, matchRuleId);

                    if (token === false && this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    }

                    // when token is false this is a lexer rule which consumes
                    // input without producing a token (e.g. whitespace)
                    return token;
                }

                if (!false) {
                    break;
                }
            }
        }

        if (match) {
            // when token is false this is a lexer rule which consumes
            // input without producing a token (e.g. whitespace)
            return this.test_match(match, matchRuleId);
        }

        if (this.eof()) {
            return 1; // EOF
        }

        this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
            text: '',
            token: null,
            line: this.yylineno
        });
    },
    lex() {
        let token;

        while (!token) {
            token = this.next();
        }

        return token;
    },
    begin(condition) {
        this.currentCondition = condition;
        this.conditionStack.push(condition);
    },
    pushState(condition) {
        this.begin(condition);
    },
    popState() {
        this.conditionStack.pop();

        return this.currentCondition = (this.conditionStack.length
            ? this.conditionStack[this.conditionStack.length - 1]
            : 'INITIAL'
        );
    },
    topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);

        return n >= 0
            ? this.conditionStack[n]
            : 'INITIAL';
    },
    stateStackSize() {
        return this.conditionStack.length;
    }
};
return lexer;
})();
;
function Parser() {
  this.yy = {};
}
Parser.prototype = {Parser,
lexer,
symbols_: {"error":2,"root":3,"block":4,"EOF":5,"definitions":6,"e":7,"def":8,"$":9,";":10,":":11,"$ident":12,"ident":13,"IDENT":14,"$IDENT":15,"condConsequent":16,"?":17,"condAlternate":18,"query":19,"FUNCTION_START":20,"FUNCTION_END":21,"FUNCTION":22,"compareFunction":23,"|":24,"NOT":25,"NO":26,"-":27,"+":28,"IS":29,"assertion":30,"IN":31,"HAS":32,"NOTIN":33,"HASNO":34,"AND":35,"OR":36,"??":37,"*":38,"/":39,"%":40,"=":41,"!=":42,"<":43,"<=":44,">":45,">=":46,"~=":47,"queryRoot":48,"relativePath":49,"@":50,"#":51,"$$":52,"STRING":53,"NUMBER":54,"REGEXP":55,"LITERAL":56,"template":57,"object":58,"array":59,"[":60,"sliceNotation":61,"]":62,"method()":63,"(":64,")":65,".":66,".(":67,".[":68,"..":69,"..(":70,"arguments":71,",":72,"templateString":73,"templateStart":74,"templateTail":75,"templateEnd":76,"templateContinue":77,"TEMPLATE":78,"TPL_START":79,"TPL_CONTINUE":80,"TPL_END":81,"{":82,"}":83,"objectEntries":84,"objectEntry":85,"...":86,"arrayElements":87,"arrayElement":88,"assertionTerm":89,"assertionList":90,"compareExpr":91,"ORDER":92,"sliceNotationComponent":93,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",9:"$",10:";",11:":",14:"IDENT",15:"$IDENT",17:"?",20:"FUNCTION_START",21:"FUNCTION_END",22:"FUNCTION",24:"|",25:"NOT",26:"NO",27:"-",28:"+",29:"IS",31:"IN",32:"HAS",33:"NOTIN",34:"HASNO",35:"AND",36:"OR",37:"??",38:"*",39:"/",40:"%",41:"=",42:"!=",43:"<",44:"<=",45:">",46:">=",47:"~=",50:"@",51:"#",52:"$$",53:"STRING",54:"NUMBER",55:"REGEXP",56:"LITERAL",60:"[",62:"]",64:"(",65:")",66:".",67:".(",68:".[",69:"..",70:"..(",72:",",78:"TEMPLATE",79:"TPL_START",80:"TPL_CONTINUE",81:"TPL_END",82:"{",83:"}",86:"...",92:"ORDER"},
productions_: [0,[3,2],[4,2],[4,1],[4,1],[4,0],[6,1],[6,2],[8,2],[8,4],[8,2],[8,4],[13,1],[12,1],[16,2],[16,1],[18,2],[18,1],[18,0],[7,1],[7,3],[7,2],[7,1],[7,3],[7,4],[7,2],[7,2],[7,2],[7,2],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[7,3],[19,1],[19,1],[48,1],[48,1],[48,1],[48,1],[48,1],[48,1],[48,1],[48,1],[48,1],[48,1],[48,1],[48,1],[48,3],[48,2],[48,2],[48,1],[48,1],[48,3],[48,4],[48,2],[48,2],[48,3],[48,3],[48,2],[48,2],[48,3],[49,3],[49,4],[49,4],[49,3],[49,3],[49,4],[49,4],[49,3],[49,3],[49,4],[63,3],[63,4],[63,3],[63,4],[71,1],[71,3],[57,1],[57,2],[75,1],[75,2],[75,2],[75,3],[73,1],[74,1],[77,1],[76,1],[58,2],[58,3],[58,4],[58,3],[58,4],[58,5],[84,1],[84,3],[85,1],[85,1],[85,1],[85,3],[85,3],[85,3],[85,3],[85,3],[85,5],[85,1],[85,2],[87,1],[87,3],[88,1],[88,1],[88,2],[59,2],[59,3],[59,4],[30,1],[30,2],[30,3],[30,4],[89,1],[89,1],[89,1],[89,1],[90,1],[90,3],[90,3],[23,1],[23,3],[91,2],[61,1],[61,2],[61,2],[61,3],[93,1],[93,2]],
table: (function unpackTable(tables) {
    function unpackSubtable(table) {
        // restore repetitions by ref
        const refs = table.match(/[\x20-\x2f]/g);
        const last = refs ? Math.max(...refs.map(ref => ref.charCodeAt() - 32)) : -1;
        for (let i = last; i >= 0; i--) {
            const idx = (32 + i).toString(16);
            let pattern;
            table = table
                .replace(new RegExp('\\[\\x' + idx + '(.+?)\\]'), (_, repl) => (pattern = repl))
                .replace(new RegExp('\\x' + idx, 'g'), pattern);
        }

        // restore repetitions
        table = table.replace(/<([^>]+?)>/g, (_, p) => {
            let n = d64[p[0]];
            let offset = 1;

            if (n >> 5 === 1) {
                n = (n & 0b11111) | (d64[p[1]] << 5);
                offset = 2;
            }

            return p.slice(offset).repeat(n);
        });

        return table;
    }

    function decodeNums(encoded) {
        const nums = [];

        for (let j = 0; j < encoded.length; j++) {
            const b1 = d64[encoded[j]];

            if (b1 & 0b100000) {
                const b2 = d64[encoded[++j]];
                nums.push((b1 & 0b11111) | (b2 << 5));
            } else {
                nums.push(b1);
            }
        }

        return nums;
    }

    const e64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~|=';
    const d64 = e64.split('').reduce((map, ch, idx) => (map[ch] = idx, map), Object.create(null));
    const [indexTable, indexRows, ...stateTables] = tables.split('=').map(unpackSubtable);
    const decodedIndexRows = indexRows.split(';').map(row => {
        const states = [];

        for (let i = 0; i < row.length; i++) {
            for (let j = 0, chunk = d64[row[i]]; j < 3; j++) {
                states.push((chunk >> (j * 2)) & 0b11);
            }
        }

        return states;
    });
    const decodedStateTables = stateTables.map(decodeNums);
    const result = decodeNums(indexTable).map(rowIdx => {
        const rowIndexes = decodedIndexRows[rowIdx];
        const row = Object.create(null);

        for (let i = 0; i < rowIndexes.length; i++) {
            const state = rowIndexes[i];

            if (state !== 0) {
                const ref = decodedStateTables[state - 1].shift();

                row[i] = state === 1 ? ref : [state - 1, ref];
            }
        }

        return row;
    });

    for (let i = 0; i < decodedStateTables[3].length; i += 2) {
        result[decodedStateTables[3][i]][decodedStateTables[3][i + 1]] = [3];
    }

    return result;
})("ABCDEFGHIJIIIIKLMMMN<KM>OPQRMSTUVTUMWXYNMZaEFSP<TI>QMbTUVTUcdMRIeeffFIFIgBhBMiBjBkBlBmBnBMMoBpB<FM>YgBqBrBRMsBt[ BhBRMt]BMMuBWMZMvBwBxByByBz<DB0>BI1B2B2BrBM<E3B>4B5Beff<D6B>7B7B<E8B>7BMM9<C >BMM~B|B|BMgChCMMiCjCjBkClCMpBmCnC2BMgCMqBMMMMWMMoCMvB<FI>pCqC2B<FM>FFMIMlBlCjCmCMPPMMMMxBxBzBMoCr<ECs>C0BhCMnCnCIMIsCsC=A1[ V[!C[\"lmkYoq]]]<GA>[#[$[%[&lqqVCJqK]U]['[(AKIAAE];]]A];Ag;AwU[)Clmkboq]<GA>[*lqqVy5qK]U'AwAA[+AkADCqo]<Fq>AAAAww<IA>g;AwADwzwP8|<GA>w||Az8|PAAP8[,[-w[.;AwA8A]][/wADD|8]]<F|>AAAAywqKDAwzAAw;AEV)<GA>#AE!<GA>#wA8A/<F|>AAAAzw|PCAwzAAw;AwAoA/<F|>AAAAzw|PDAwzAAw;AwAoA/<F|>AAAAz4|PDAwzAA,<F|>AAAAzw|PDAwzAA,<F|>AAAAz8|PDAwzAAw;AAEi\"<GA>lqqVmJqKUAKIgFEB;AAAChCAAIAB<HA>gAAI<HA>Q;AwAsAwBDD|8<F|>AAAAzw|PDAwzAA,<F|>AAAAz4|PDAwzAAw;AA <GA>#AAAlC<PA>B;AE <GA>lqqVC5qKU'AE <GA>lqqVyJqKU'AAE!<GA>%VqKAAE;AARClC<LA>giAC<GA>gl;AwE~lmkbrq8<F|>*XA67AA0;AAADwzwM8|<GA>w||ADM|PAA|P;M;AAEi\"<GA>lqqVmJqKU(B;<HA>C;AwA8+<Fq>AAAAzw|PDAwzAAg.0ADDqo6vqqqAAAAzw|PDAwzAA-0ADDv8|v6||AAAAzw|PDAwzAAw;AAE!<GA>lqqVCpqaU(<C;AAAAAAAAAAAAAAAAAAAAg>AAAC;AAAg<QA>w<KA>B;AAAgAkAACqo<Fq>AAAAwAAAD<FA>gB;<UA>wAAAD;AAEy\"<GA>lqqVyJqKU'AAE!<GA>lqqVyJqKX'AAAChC<MA>gAAI<HA>Q;AAAChCAAIAB<HA>gAAI<HA>QB;<FA>kAACqo<Fq><FA>g<IA>g;AAU!<GA>$<VA>I;<VA>g;<FA>kAACqo<Fq><JA>UgCAAg;<YA>CAAg;AAQClC<LA>giAC<GA>gl;<YA>DAAw;AAAo<UA>DAAw;AAAg<UA>DAAw;AAAg;AAAClmEAAg<GA>&XAK4.kADDqo<Fq>AAAAzw|PDAwzAA-0ADDq8|vqqqAAAAzw|PDAwzAA-0ADDqo6rqqqAAAAzw|PDAwzAA-0ADDqoqrqqqAAAAzw|PDAwzAA-0ADDv8<F|>AAAAzw|PDAwzAA-0ADDq8|v6r6AAAAzw|PDAwzAA-0ADDq8|v6||AAAAzw|PDAwzAAw;AAAgAkAACqo<Fq>AAAAg<JA>gB;<FA>kAACqo<Fq><OA>g;AAAIAkAACqo<Fq><OA>g;<VA>gAAC;<FA>kAACqo<Fq><FA>wAAD<FA>g;AAE!<GA>lqqViJqKUAKIgEE;<UA>w;AAAwAkAACqo<Fq>AAAAw<JA>g;<FA>kAACqo<Fq>AAAAwAAAD<FA>g;<LA>gC<IA>g;<LA>wD<IA>w;AAAClC<LA>giAC<GA>gk;<FA>kAACqo<Fq>AAAAg<JA>g;<UA>CAqKDAAw;AAAIAkAACqo<Fq><IA>DAAwAAg;<FA>kAACqo<Fq><IA>DAAwAAg=B[ C[!D[\"E[#F[$P[%[&['[(hBgBGJQRbcd]iB]pBqB]S]]]]]x]ByB$oCw CzC%1CzC%2CzC%3CzC%4CzC%iDzC(~C[)iBpBqB]gDjDShDsDmDnDuDyDxD#1DzD0D2D!3D!1D4D5D6D!9DzC&7D8D~DSjEFmEnEiEkEtEzC%oCvEu\"sDwEnDxEzC%yEzC%zEzC%0EzC%1EzC%2EzC%3EzC%4EzC%5EzC%6EzC%7EzC%8EzC%9EzC%~EzC%|EzC%gFzC%hFzC%iFzC%jFzC%kFmFzC(nF)ShD1DoFpFqF!rF!1DsFtFuF!oCxFzC&wF<EoC>yFzC%zF[*zC%2FzC']1FpBqBS6FoC7F8FzC%9FzC%sD~F[+sDhGnD]gGiG*kGpBqBSoCmGyB$oCqGrG[,9DzC&s]G8D~DSyBmEnEwGkE2GzC%zChBgB3GQRbcd)oCoC4GyB$<UoC>7F<EoC>kHzC&jHSlHoCoC+mHoCoC,H8D~DS[-wHnEuH]zHzC%0HzC%1HzC%2HzC%3[.HzC%oC]oC5.sD7HnDsD8HnD-<GoC>gIzC%hIzC%oCoC=[ [!O[\"[#[$[%tBTsBHIKLMN[&fUVWXYZae]]jB]['kBlBmBnBoBuBvB]]rB]]w]B![([)sBz[*B[+[,[-9B8B0B]1B2B3B4B]5B]6B[.7[/B~B|BgC]hCiCjCkClCmCnC]]]pC]qCrCsCtCuCvC!yC\"0C<EyC\">5C6C7C8C9CyCkD%|CjB'rBlDrDqDToDtDpDvDwD<C!tBT!>yC#gE|DrBlEtBToEpEqErEhEsEyC\"(!rDqDToDtDpD<TyC\">vDyCkD%lFjB'rBtBT<C!>tBT!vF(9CyC\"<C,~B|BgChCiCjCkClCmCnC><C0/><CyC\">yC$0F'rB3F4F5FkDkD(<CyC\">rDqDTtD|FrDqDToDtDpDyC\"yC$jG'rB)lGpC D9CnGoGwDpG)gE|DpCyC#gE|DrBuGtGlEtBToEpEqErEvGsE5C6C7CxGyGzG0G1GyC\"yCtBTsB&jB'rB<Cs*>!<E-~B|BgChCiCjCkClCmCnC>,.+.,~B|BgChCiCjCkClCmCn<CC0B~B|Bg>C<D0B><C-~B|BgCjCkClCmC><F-~B|BgC>jCkClCmCkD)5GpC6GwD7G8GwD9G(~G(|G(gHhH(yC%iHjB'rBlDkD<C(>rDqDToDtDpDoHpHnHs*qHhH)rHpCyC#gE|DrBvHtBToEpEqErEtHsEyHxH<FyC\">)4HpCqCrCsCtCuCvCs*yC\"(oHpH6H<CrDqDToDtDpD>9HvHtBToEpEqErE~HsE|G<F(>|H(<CyC\"><C(>=FDDDDEEEE<iBG><hBT>F<mBW><lB2B><lB4B><nByB><nBzB><nBuE><oBN><nB0B><nB1B><nB3B><nB5B><nB6B><nB7B><nB8B><nB9B><nB~B><nB|B><mBS><nBjC><nBkC>FFF<nB~C><dP><oBM><nBkD><elD>BCCCC<iBH><mBS><nBwE>FFF<QV><nB2B><nB4B><WZ><Wa><jBb><jBc><iBI><iBK><nBgE>xE9D9D7D7D1E1E~D~D<nBhC><nBjE><nBnE><nBoE><nBpE><nBqE><nBiC><dR><nBnC><nBoC><nBrC><nBsC><nB|C><nBgD><nBnD><emD><nBoD>uDu[ DwDwDxDxD]yDyD5D5D<SO><SX><nBd><ae><af><agB><ahB><ViB><UjB><WkB><jBlB><jBmB><mBnB><mBoB><mBpB><dqB><drB><hBsB><hBtB><hBuB><hBvB><dwB><nBxB><nBuC><nBxC><nByC><nB1C><nB2C><nBU><nBvE><nB6C>8C8C<nBgC><nBhE>yEzE2E2E|D|D<nBkE><DrE><SQ><nB4C><nBlC><nBpC><nBqC><nBtC><nBhD><nBiD><nBpD><nBrD>6D6D<SY><nBvC><nBwC><nBzC><nB0C><nB3C><iBJ><iBL><nB7C><nBiE>8D8D9D9D0<nBEl>E<nB5C><nBmC><nBjD><nBqD>vDv <nBsD>3D3DzDzD0D0D1D1D2D2D9C9C<nBmE><DsE><DtE><nBtD>3D3D4D4D=BB"),
defaultActions: {48:[2,1],186:[2,146],229:[2,148]},
performAction(yytext,yyleng,yylineno,yy,yystate /* action[1] */,$$ /* vstack */,_$ /* lstack */) {
/* this == yyval */

const $0 = $$.length - 1;
switch (yystate) {
case 1:
return yy.buildResult($$[$0-1])
break;
case 2:
this.$ = {type:"Block",definitions:$$[$0-1],body:$$[$0],range:this._$.range};
break;
case 3:
this.$ = {type:"Block",definitions:$$[$0],body:{type:"Placeholder",range:[_$[$0].range[1],_$[$0].range[1]]},range:this._$.range};
break;
case 4:
this.$ = {type:"Block",definitions:[],body:$$[$0],range:this._$.range};
break;
case 5:
this.$ = {type:"Block",definitions:[],body:{type:"Placeholder",range:[_$[$0].range[1],_$[$0].range[1]]},range:this._$.range};
break;
case 6: case 92: case 94: case 110: case 123: case 139: case 142:
this.$ = [$$[$0]];
break;
case 7:
$$[$0-1].push($$[$0]);
break;
case 8:
this.$ = {type:"Definition",declarator:{type:"Declarator",name:null,range:_$[$0-1].range},value:null,range:this._$.range};
break;
case 9:
this.$ = {type:"Definition",declarator:{type:"Declarator",name:null,range:_$[$0-3].range},value:$$[$0-1],range:this._$.range};
break;
case 10:
this.$ = {type:"Definition",declarator:{type:"Declarator",name:$$[$0-1].name,range:_$[$0-1].range},value:null,range:this._$.range};
break;
case 11:
this.$ = {type:"Definition",declarator:{type:"Declarator",name:$$[$0-3].name,range:_$[$0-3].range},value:$$[$0-1],range:this._$.range};
break;
case 12: case 13: case 135: case 136:
this.$ = {type:"Identifier",name:$$[$0],range:this._$.range};
break;
case 14: case 16: case 150:
this.$ = $$[$0];
break;
case 15: case 17: case 18: case 149:
this.$ = null;
break;
case 19: case 50: case 51: case 62: case 63: case 125:

break;
case 20:
this.$ = {type:"Function",arguments:[],body:$$[$0-1],legacy:true,range:this._$.range};
break;
case 21:
this.$ = {type:"Function",arguments:[],body:$$[$0],legacy:false,range:this._$.range};
break;
case 22:
this.$ = {type:"CompareFunction",compares:$$[$0],range:this._$.range};
break;
case 23:
this.$ = {type:"Pipeline",left:$$[$0-2],right:$$[$0],range:this._$.range};
break;
case 24:
this.$ = {type:"Pipeline",left:$$[$0-3],right:{type:"Block",definitions:$$[$0-1],body:$$[$0]},range:this._$.range};
break;
case 25: case 26: case 27: case 28: case 65:
this.$ = {type:"Prefix",operator:$$[$0-1],argument:$$[$0],range:this._$.range};
break;
case 29:
this.$ = {type:"Postfix",operator:$$[$0],argument:$$[$0-2],range:this._$.range};
break;
case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47: case 48:
this.$ = {type:"Binary",operator:$$[$0-1],left:$$[$0-2],right:$$[$0],range:this._$.range};
break;
case 49:
this.$ = {type:"Conditional",test:$$[$0-2],consequent:$$[$0-1],alternate:$$[$0],range:this._$.range};
break;
case 52:
this.$ = {type:"Data",range:this._$.range};
break;
case 53:
this.$ = {type:"Context",range:this._$.range};
break;
case 54:
this.$ = {type:"Current",range:this._$.range};
break;
case 55:
this.$ = {type:"Arg1",range:this._$.range};
break;
case 56:
this.$ = {type:"Reference",name:$$[$0],range:this._$.range};
break;
case 57: case 58: case 59: case 60: case 100: case 101: case 102: case 103:
this.$ = {type:"Literal",value:$$[$0],range:this._$.range};
break;
case 61:
this.$ = {type:"Template",values:$$[$0],range:this._$.range};
break;
case 64:
this.$ = {type:"SliceNotation",value:null,arguments:$$[$0-1],range:this._$.range};
break;
case 66:
this.$ = {type:"Conditional",test:null,consequent:$$[$0-1],alternate:$$[$0],range:this._$.range};
break;
case 67: case 71:
this.$ = {type:"GetProperty",value:null,property:$$[$0],range:this._$.range};
break;
case 68: case 72:
this.$ = {type:"MethodCall",value:null,method:$$[$0],range:this._$.range};
break;
case 69:
this.$ = {type:"Parentheses",body:$$[$0-1],range:this._$.range};
break;
case 70:
this.$ = {type:"Parentheses",body:{type:"Block",definitions:$$[$0-2],body:$$[$0-1]},range:this._$.range};
break;
case 73:
this.$ = {type:"Map",value:null,query:$$[$0-1],range:this._$.range};
break;
case 74:
this.$ = {type:"Filter",value:null,query:$$[$0-1],range:this._$.range};
break;
case 75:
this.$ = {type:"MapRecursive",value:null,query:{type:"GetProperty",value:null,property:$$[$0]},range:this._$.range};
break;
case 76:
this.$ = {type:"MapRecursive",value:null,query:{type:"MethodCall",value:null,method:$$[$0]},range:this._$.range};
break;
case 77:
this.$ = {type:"MapRecursive",value:null,query:$$[$0-1],range:this._$.range};
break;
case 78:
this.$ = {type:"Pick",value:$$[$0-2],getter:null,range:this._$.range};
break;
case 79:
this.$ = {type:"Pick",value:$$[$0-3],getter:$$[$0-1],range:this._$.range};
break;
case 80:
this.$ = {type:"SliceNotation",value:$$[$0-3],arguments:$$[$0-1],range:this._$.range};
break;
case 81:
this.$ = {type:"GetProperty",value:$$[$0-2],property:$$[$0],range:this._$.range};
break;
case 82:
this.$ = {type:"MethodCall",value:$$[$0-2],method:$$[$0],range:this._$.range};
break;
case 83:
this.$ = {type:"Map",value:$$[$0-3],query:$$[$0-1],range:this._$.range};
break;
case 84:
this.$ = {type:"Filter",value:$$[$0-3],query:$$[$0-1],range:this._$.range};
break;
case 85:
this.$ = {type:"MapRecursive",value:$$[$0-2],query:{type:"GetProperty",value:null,property:$$[$0]},range:this._$.range};
break;
case 86:
this.$ = {type:"MapRecursive",value:$$[$0-2],query:{type:"MethodCall",value:null,method:$$[$0]},range:this._$.range};
break;
case 87:
this.$ = {type:"MapRecursive",value:$$[$0-3],query:$$[$0-1],range:this._$.range};
break;
case 88:
this.$ = {type:"Method",reference:$$[$0-2],arguments:[],range:this._$.range};
break;
case 89:
this.$ = {type:"Method",reference:$$[$0-3],arguments:$$[$0-1],range:this._$.range};
break;
case 90:
this.$ = {type:"Method",reference:{type:"Reference",name:$$[$0-2]},arguments:[],range:this._$.range};
break;
case 91:
this.$ = {type:"Method",reference:{type:"Reference",name:$$[$0-3]},arguments:$$[$0-1],range:this._$.range};
break;
case 93: case 111: case 124: case 143:
$$[$0-2].push($$[$0]);
break;
case 95:
this.$=[$$[$0-1], ...$$[$0]];
break;
case 96: case 145:
this.$ = [null,$$[$0]];
break;
case 97: case 147:
this.$ = [$$[$0-1],$$[$0]];
break;
case 98:
this.$=[null, $$[$0-1], ...$$[$0]];
break;
case 99:
this.$=[$$[$0-2], $$[$0-1], ...$$[$0]];
break;
case 104: case 107:
this.$ = {type:"Object",properties:[],range:this._$.range};
break;
case 105:
this.$ = {type:"Object",properties:$$[$0-1],range:this._$.range};
break;
case 106:
this.$ = {type:"Object",properties:$$[$0-2],range:this._$.range};
break;
case 108:
this.$ = {type:"Block",definitions:$$[$0-2],body:{type:"Object",properties:$$[$0-1]},range:this._$.range};
break;
case 109:
this.$ = {type:"Block",definitions:$$[$0-3],body:{type:"Object",properties:$$[$0-2]},range:this._$.range};
break;
case 112:
this.$ = {type:"ObjectEntry",key:{type:"Current"},value:null,range:this._$.range};
break;
case 113:
this.$ = {type:"ObjectEntry",key:{type:"Reference",name:$$[$0]},value:null,range:this._$.range};
break;
case 114:
this.$ = {type:"ObjectEntry",key:$$[$0],value:null,range:this._$.range};
break;
case 115:
this.$ = {type:"ObjectEntry",key:$$[$0-2],value:$$[$0],range:this._$.range};
break;
case 116: case 117: case 118:
this.$ = {type:"ObjectEntry",key:{type:"Literal",value:$$[$0-2]},value:$$[$0],range:this._$.range};
break;
case 119:
this.$ = {type:"ObjectEntry",key:{type:"Identifier",name:"$" + $$[$0-2].name},value:$$[$0],range:this._$.range};
break;
case 120:
this.$ = {type:"ObjectEntry",key:$$[$0-3],value:$$[$0],range:this._$.range};
break;
case 121:
this.$ = {type:"Spread",query:null,array:false,range:this._$.range};
break;
case 122:
this.$ = {type:"Spread",query:$$[$0],array:false,range:this._$.range};
break;
case 126:
this.$ = {type:"Spread",query:null,array:true,range:this._$.range};
break;
case 127:
this.$ = {type:"Spread",query:$$[$0],array:true,range:this._$.range};
break;
case 128:
this.$ = {type:"Array",elements:[],range:this._$.range};
break;
case 129:
this.$ = {type:"Array",elements:$$[$0-1],range:this._$.range};
break;
case 130:
this.$ = {type:"Array",elements:$$[$0-2],range:this._$.range};
break;
case 131:
this.$ = {type:"Assertion",negation:false,assertion:$$[$0],range:this._$.range};
break;
case 132:
this.$ = {type:"Assertion",negation:true,assertion:$$[$0],range:this._$.range};
break;
case 133:
this.$ = {type:"Assertion",negation:false,assertion:$$[$0-1],range:this._$.range};
break;
case 134:
this.$ = {type:"Assertion",negation:true,assertion:$$[$0-1],range:this._$.range};
break;
case 137:
this.$ = {type:"Method",reference:{type:"Reference",name:$$[$0]},arguments:[],range:this._$.range};
break;
case 138:
this.$ = {type:"Identifier",name:String($$[$0]),range:this._$.range};
break;
case 140: case 141:
$$[$0-2].push($$[$0-1], $$[$0]);
break;
case 144:
this.$ = {type:"Compare",query:$$[$0-1],order:$$[$0],range:this._$.range};
break;
case 146:
this.$ = [null,$$[$0-1],$$[$0]];
break;
case 148:
this.$ = [$$[$0-2],$$[$0-1],$$[$0]];
break;
}
},
trace(...args) {
        if (this.DEBUG) {
            Jison.print(...args);
        }
    },
parseError(str, hash) {
        if (hash.recoverable) {
            this.trace(str);
        } else {
            const error = new Error(str);
            error.hash = hash;
            throw error;
        }
    },
parse(input, ...parseArgs) {
    // use own constants for source generation reasons
    const SHIFT = 1;
    const REDUCE = 2;
    const ACCEPT = 3;
    const TERROR = 2;
    const EOF = 1;

    const popStack = n => {
        stack.length -= 2 * n;
        vstack.length -= n;
        lstack.length -= n;
    };
    const lex = /** @replace token stack */ () => {
        let token = lexer.lex() || EOF;

        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = this.symbols_[token] || token;
        }

        return token;
    }; /** @replace */

    const lexer = Object.create(this.lexer);
    const ranges = lexer.options && lexer.options.ranges;
    const sharedYY = { // shared state
        ...this.yy,
        parser: this,
        lexer
    };

    lexer.setInput(input, sharedYY);

    if (typeof sharedYY.parseError === 'function') {
        this.parseError = sharedYY.parseError;
    }

    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }

    const table = this.table;
    const yyval = {};
    let yylloc = lexer.yylloc;
    const stack = [0];
    const vstack = [null]; // semantic value stack
    const lstack = [yylloc]; // location stack
    // eslint-disable-next-line no-unused-vars
    let tstack = []; // token stack, used when lex supports token stacks
    let yytext = '';
    let yylineno = 0;
    let yyleng = 0;
    let recovering = 0;
    let symbol;
    let preErrorSymbol;
    while (true) {
        // retreive state number from top of stack
        let state = stack[stack.length - 1];
        let action;

        // use default actions if available
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }

            // read action for current state and first input
            action = table[state] && table[state][symbol];
        }

        // handle parse error
        if (!action || !action[0]) {
            let errorRuleDepth;
            let errStr = '';

            // Return the rule stack depth where the nearest error rule can be found.
            // Return FALSE when no error recovery rule was found.
            function locateNearestErrorRecoveryRule(state) {
                let stackProbe = stack.length - 1;
                let depth = 0;

                // try to recover from error
                while (true) {
                    // check for error recovery rule in this state
                    if (TERROR.toString() in table[state]) {
                        return depth;
                    }

                    if (state === 0 || stackProbe < 2) {
                        return false; // No suitable error recovery rule available.
                    }

                    stackProbe -= 2; // popStack(1): [symbol, action]
                    state = stack[stackProbe];
                    ++depth;
                }
            }

            if (!recovering) {
                // first see if there's any chance at hitting an error recovery rule:
                

                // Report error
                const expected = [];
                for (const p in table[state]) {
                    if (p in this.terminals_ && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }

                errStr = lexer.showPosition
                    ? 'Parse error on line ' + (yylineno + 1) + ':\n' +
                        lexer.showPosition() + '\n' +
                        'Expecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\''
                    : 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' +
                        (symbol === EOF ? 'end of input' : "'" + (this.terminals_[symbol] || symbol) + "'");

                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yylloc,
                    
                    expected
                });
            } else if (preErrorSymbol !== EOF) {
                
            }

            // just recovered from another error
            if (recovering === 3) {
                if (symbol === EOF || preErrorSymbol === EOF) {
                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');
                }

                // discard current lookahead and grab another
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yylloc = lexer.yylloc;
                symbol = lex();
            }

            // try to recover from error
            if (errorRuleDepth === false) {
                throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');
            }

            popStack(errorRuleDepth);
            preErrorSymbol = symbol == TERROR ? null : symbol; // save the lookahead token
            symbol = TERROR; // insert generic error symbol as new lookahead
            state = stack[stack.length - 1];
            action = table[state] && table[state][TERROR];
            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error
        }

        // this shouldn't happen, unless resolve defaults are off
        if (Array.isArray(action[0]) && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }

        switch (action[0]) {
            case SHIFT:
                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;

                if (!preErrorSymbol) { // normal execution/no error
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yylloc = lexer.yylloc;
                    if (recovering > 0) {
                        recovering--;
                    }
                } else {
                    // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }

                break;

            case REDUCE: {
                const len = this.productions_[action[1]][1];
                const first = lstack[lstack.length - (len || 1)];
                const last = lstack[lstack.length - 1];

                // perform semantic action
                yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: first.first_line,
                    last_line: last.last_line,
                    first_column: first.first_column,
                    last_column: last.last_column
                };

                if (ranges) {
                    yyval._$.range = [
                        first.range[0],
                        last.range[1]
                    ];
                }

                const actionResult = this.performAction.call(
                    yyval,
                    yytext,
                    yyleng,
                    yylineno,
                    sharedYY,
                    action[1],
                    vstack,
                    lstack,
                    ...parseArgs
                );

                if (typeof actionResult !== 'undefined') {
                    return actionResult;
                }

                // pop off stack
                if (len) {
                    popStack(len);
                }

                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                stack.push(table[stack[stack.length - 2]][stack[stack.length - 1]]);
                break;
            }

            case ACCEPT:
                return true;
        }
    }
}};
const parser = (function buildParsers(strictParser) {
    function patch(subject, patches) {
        Object.entries(patches).forEach(([key, patch]) =>
            subject[key] = patch(subject[key])
        );
    }

    // better error details
    const humanTokens = new Map([
        ['EOF', ['<end of input>']],
        ['IDENT', ['ident']],
        ['$IDENT', ['$ident']],
        ['FUNCTION_START', ["'<'"]],
        ['FUNCTION_END', ["'>'"]],
        ['FUNCTION', ["'=>'"]],
        ['NOT', ["'not'"]],
        ['NO', ["'no'"]],
        ['IS', ["'is'"]],
        ['THEN', ["'then'"]],
        ['ELSE', ["'else'"]],
        ['IN', ["'in'"]],
        ['HAS', ["'has'"]],
        ['NOTIN', ["'not in'"]],
        ['HASNO', ["'has no'"]],
        ['AND', ["'and'"]],
        ['OR', ["'or'"]],
        ['STRING', ['string']],
        ['TPL_START', ['template']],
        ['TEMPLATE', ['template']],
        ['NUMBER', ['number']],
        ['REGEXP', ['regexp']],
        ['LITERAL', ["'true'", "'false'", "'null'", "'undefined'", "'NaN'", "'Infinity'"]],
        ['ORDER', ["'asc'", "'desc'", "'ascN'", "'descN'"]]
    ]);
    const tokenForHumans = token => humanTokens.get(token) || `'${token}'`;
    const parseError = function(rawMessage, details = {}, yy) {
        if (details.recoverable) {
            this.trace(rawMessage);
        } else {
            if (Array.isArray(details.inside)) {
                const start = yy.lexer.offset - yy.lexer.match.length;

                yy.lexer.setMatch(
                    start + details.inside[0],
                    start + details.inside[1]
                );
            }

            const yylloc = yy.lexer.yylloc;
            const message = [
                rawMessage.split(/\n/)[0],
                '',
                yy.lexer.showPosition()
            ];
            const expected = !Array.isArray(details.expected) ? null : [...new Set([].concat(
                ...details.expected.map(token => tokenForHumans(token.slice(1, -1)))
            ))];

            if (expected) {
                message.push(
                    '',
                    'Expecting ' + expected.join(', ') + ' got ' + tokenForHumans(details.token)
                );
            }

            const error = new SyntaxError(message.join('\n'));

            error.details = {
                rawMessage: rawMessage,
                text: details.text,
                token: details.token,
                expected,
                loc: {
                    range: yylloc.range,
                    start: {
                        line: yylloc.first_line,
                        column: yylloc.first_column,
                        offset: yylloc.range[0]
                    },
                    end: {
                        line: yylloc.last_line,
                        column: yylloc.last_column,
                        offset: yylloc.range[1]
                    }
                }
            };

            throw error;
        }
    };

    // add new helpers to lexer
    const lineTerminator = new Set(['\n', '\r', '\u2028', '\u2029']);
    const literals = new Map([
        ['undefined', undefined],
        ['null', null],
        ['false', false],
        ['true', true],
        ['Infinity', Infinity],
        ['NaN', NaN]
    ]);
    Object.assign(strictParser.lexer, {
        ident: value => value.replace(/\\u[0-9a-fA-F]{4}/g, m => String.fromCharCode(parseInt(m.slice(2), 16))),

        toLiteral: value => literals.get(value),

        toStringLiteral(value, multiline = false, end = 1) {
            const valueEnd = value.length - end;
            let result = '';

            for (let i = 1; i < valueEnd; i++) {
                if (!multiline && lineTerminator.has(value[i])) {
                    this.parseError('Invalid line terminator', { inside: [i, i + 1] });
                }

                if (value[i] !== '\\') {
                    result += value[i];
                    continue;
                }

                if (i === valueEnd - 1) {
                    this.parseError('Invalid backslash', { inside: [i, i + 1] });
                }

                const next = value[++i];
                switch (next) {
                    case '\r':
                        // ignore line terminator
                        i += value[i + 1] === '\n';  // \r\n
                        break;

                    case '\n':
                    case '\u2028':
                    case '\u2029':
                        // ignore line terminator
                        break;

                    case '0': result += '\0'; break;
                    case 'b': result += '\b'; break;
                    case 'n': result += '\n'; break;
                    case 'r': result += '\r'; break;
                    case 'f': result += '\f'; break;
                    case 't': result += '\t'; break;
                    case 'v': result += '\v'; break;

                    case 'u': {
                        const [hex = ''] = value.slice(i + 1, i + 5).match(/^[0-9a-f]*/i) || [];

                        if (hex.length === 4) {
                            result += String.fromCharCode(parseInt(hex, 16));
                            i += 4;
                            break;
                        }

                        this.parseError('Invalid Unicode escape sequence', {
                            inside: [i - 1, Math.min(i + 1 + hex.length, valueEnd)]
                        });
                        break;
                    }

                    case 'x': {
                        const [hex = ''] = value.slice(i + 1, i + 3).match(/^[0-9a-f]*/i) || [];

                        if (hex.length === 2) {
                            result += String.fromCharCode(parseInt(hex, 16));
                            i += 2;
                            break;
                        }

                        this.parseError('Invalid hexadecimal escape sequence', {
                            inside: [i - 1, Math.min(i + 1 + hex.length, valueEnd)]
                        });
                        break;
                    }

                    default:
                        result += next;
                }
            }

            return result;
        },

        toRegExp(value) {
            const flagsIndex = value.lastIndexOf('/') + 1;
            const flags = value.substr(flagsIndex);

            flags.split('').forEach((flag, idx, array) => {
                const duplicateIndex = array.indexOf(flag, idx + 1);
                if (duplicateIndex !== -1) {
                    this.parseError('Duplicate flag in regexp', {
                        inside: [flagsIndex + duplicateIndex, flagsIndex + duplicateIndex + 1]
                    });
                }
            });

            return new RegExp(
                value.substr(1, value.lastIndexOf('/') - 1),
                flags
            );
        }
    });

    // patch setInput method to add additional lexer fields on init
    patch(strictParser.lexer, {
        setInput: origSetInput => function(input, yy) {
            const commentRanges = [];

            yy.commentRanges = commentRanges;
            yy.buildResult = ast => ({
                ast,
                commentRanges
            });
            yy.parseError = function(...args) {
                // parser doesn't expose sharedState and it's unavailable in parseError
                return parseError.call(this, ...args, yy);
            };
            yy.pps = () => {
                if (!this.eof()) {
                    this.begin('preventPrimitive');
                }
            };

            this.fnOpened = 0;
            this.fnOpenedStack = [];
            this.bracketStack = [];
            this.prevToken = null;
            this.prevYylloc = {
                first_line: 1,
                last_line: 1,
                first_column: 0,
                last_column: 0,
                range: [0, 0]
            };

            return origSetInput.call(this, input, yy);
        }
    });

    //
    // tolerant parser
    //
    const tolerantParser = new strictParser.Parser();
    tolerantParser.lexer = { ...strictParser.lexer };
    tolerantParser.yy = { ...strictParser.yy };

    // patch tolerant parser lexer
    const keywords = [
        'AND', 'OR', 'IN', 'NOTIN', 'HAS', 'HASNO',
        'IS', 'THEN', 'ELSE'
    ];
    const words = [...keywords, 'NOT', 'NO', 'ORDER'];
    const operators = [
        '+', '-', '*', '/', '%', '|',
        '=', '!=', '~=', '>=', '<=', '<', '>'
    ];
    const prev = [
        null, '?', ':', ';',
        ',', '.', '..',
        '(', '[',
        '.(', '..(', '.[',
        'FUNCTION',
        ...operators,
        ...keywords,
        'NOT', 'NO'
    ];
    const defaultNext = [
        ',', '?', ':', ';', 'EOF',
        ']', ')', '}',
        'TPL_CONTINUE', 'TPL_END',
        ...operators,
        ...keywords,
        'ORDER'
    ];
    const tokenPair = new Map(prev.map(token => [token, new Set(defaultNext)]));
    // special cases
    for (const token of ['(', '.(', '..(']) {
        tokenPair.get(token).delete(')');
    }
    for (const token of ['[', '.[']) {
        tokenPair.get(token).delete(']');
    }

    patch(tolerantParser.lexer, {
        lex: origLex => function patchedLex() {
            const prevOffset = this.offset;
            const nextToken = origLex.call(this);

            if (tokenPair.has(this.prevToken) && tokenPair.get(this.prevToken).has(nextToken)) {
                const yylloc = {
                    first_line: this.prevYylloc.last_line,
                    last_line: this.yylloc.first_line,
                    first_column: this.prevYylloc.last_column,
                    last_column: this.yylloc.first_column,
                    range: [this.prevYylloc.range[1], this.yylloc.range[0]]
                };
                this.unput(this.match);
                this.pushState('preventPrimitive');
                this.done = false;
                this.yytext = '';
                this.yylloc = this.prevYylloc = yylloc;

                // position correction for a white space before a keyword
                if (prevOffset !== this.offset && words.includes(nextToken)) {
                    switch (this._input[prevOffset]) {
                        case ' ':
                        case '\t':
                            yylloc.last_column--;
                            yylloc.range[1]--;
                            break;

                        case '\n': {
                            const lastN = this._input.lastIndexOf('\n', prevOffset - 1);

                            yylloc.last_line--;
                            yylloc.last_column = lastN === -1
                                ? yylloc.last_column - 1
                                : prevOffset - lastN;
                            yylloc.range[1]--;
                            break;
                        }
                    }
                }

                return this.prevToken = 'IDENT';
            }

            this.prevYylloc = this.yylloc;

            // position correction for a white space after a keyword
            if (words.includes(nextToken)) {
                switch (this._input[this.offset]) {
                    case ' ':
                    case '\t':
                        this.prevYylloc = {
                            ...this.prevYylloc,
                            last_column: this.prevYylloc.last_column + 1,
                            range: [this.prevYylloc.range[0], this.prevYylloc.range[1] + 1]
                        };
                        break;

                    case '\n':
                        this.prevYylloc = {
                            ...this.prevYylloc,
                            last_line: this.prevYylloc.last_line + 1,
                            last_column: 0,
                            range: [this.prevYylloc.range[0], this.prevYylloc.range[1] + 1]
                        };
                        break;
                }
            }

            return this.prevToken = nextToken;
        }
    });

    // bracket balance & scope
    const openBalance = new Map([
        ['(', ')'],
        ['.(', ')'],
        ['..(', ')'],
        ['[', ']'],
        ['.[', ']'],
        ['{', '}'],
        ['TPL_START', 'TPL_END']
    ]);
    const closeBalance = new Set([')', ']', '}', 'TPL_END']);
    const balanceScopeLex = origLex => function patchedLex() {
        const token = origLex.call(this);

        if (closeBalance.has(token)) {
            const expected = this.bracketStack.pop();

            if (expected !== token) {
                this.parseError(`Expected "${expected}" got "${token}"`);
            }

            this.fnOpened = this.fnOpenedStack.pop() || 0;
        }

        if (openBalance.has(token)) {
            this.bracketStack.push(openBalance.get(token));
            this.fnOpenedStack.push(this.fnOpened);
            this.fnOpened = 0;
        }

        return token;
    };
    patch(strictParser.lexer, {
        lex: balanceScopeLex
    });
    patch(tolerantParser.lexer, {
        lex: balanceScopeLex
    });

    return {
        parse(source, tolerantMode) {
            return tolerantMode
                ? tolerantParser.parse(source)
                : strictParser.parse(source);
        },
        *tokenize(source, tolerantMode, loc) {
            const parser = tolerantMode ? tolerantParser : strictParser;
            const lexer = Object.create(parser.lexer);

            lexer.setInput(source, { parser });

            while (!lexer.done) {
                const token = {
                    type: lexer.lex(),
                    value: lexer.match,
                    offset: lexer.yylloc.range[0]
                };

                if (loc) {
                    token.loc = {
                        range: lexer.yylloc.range,
                        start: {
                            line: lexer.yylloc.first_line,
                            column: lexer.yylloc.first_column
                        },
                        end: {
                            line: lexer.yylloc.last_line,
                            column: lexer.yylloc.last_column
                        }
                    };
                }

                yield token;
            }
        }
    };
})(new Parser);

module.exports = parser;
