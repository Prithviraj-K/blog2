import { Range, SemVer } from 'semver';
import { Item } from '../network-type-list';
import Graph, { Node as GraphNode, PathSolution } from '../graph';
import { colorFromH } from './colors';
export interface BaseDiffItem {
    id?: string;
    title?: string;
}
export interface TimeDiffItem extends BaseDiffItem {
    type: 'time';
    a: number;
    b: number;
}
export interface SizeDiffItem extends BaseDiffItem {
    type: 'size';
    a: number;
    b: number;
}
export interface NumberDiffItem extends BaseDiffItem {
    type: 'number';
    a: number;
    b: number;
    plural?: {
        words: string[];
    };
}
export interface VersionDiffItem extends BaseDiffItem {
    type: 'version';
    a: string;
    b: string;
}
export type Limit = {
    type: 'absolute';
    number: number;
} | {
    type: 'percent';
    number: number;
};
export type ValueDiff = {
    absolute: number;
    percent: number;
};
export type SerializedStringOrRegexp = {
    type: 'string';
    content: string;
} | {
    type: 'regexp';
    content: string;
    flags: string;
};
export type DiffItem = TimeDiffItem | SizeDiffItem | NumberDiffItem | VersionDiffItem;
export default function helpers(): {
    stringify: {
        (value: any, replacer?: ((this: any, key: string, value: any) => any) | undefined, space?: string | number | undefined): string;
        (value: any, replacer?: (string | number)[] | null | undefined, space?: string | number | undefined): string;
    };
    typeof(value: unknown): string;
    isNullish(value: unknown): boolean;
    isArray(value: unknown): boolean;
    useNotNullish<T>(values: readonly T[]): T | null;
    serializeStringOrRegexp(value?: string | RegExp): SerializedStringOrRegexp | null;
    deserializeStringOrRegexp(value?: SerializedStringOrRegexp | null): string | RegExp | null;
    toNumber(str: string): number;
    formatSize(value: number): string;
    formatDate(ts: number, locale?: string | string[], options?: Intl.DateTimeFormatOptions): string;
    formatDuration(ms: number): string;
    percentFrom(a: number, b: number, toFixed?: number): number;
    toFixed(value: number, digits?: number): string;
    color: (value: string) => string;
    fileExt: (value?: string) => string;
    fileType: (value?: string) => string;
    toMatchRegexp: (value: string, rx: RegExp) => boolean;
    toRegexp: (value: string) => RegExp;
    colorFromH: typeof colorFromH;
    plural(value: number, words: string[]): string;
    pluralWithValue(value: number, words: string[]): string;
    pluralRus(value: number, words: string[]): string;
    pluralWithValueRus(value: number, words: string[]): string;
    getNetworkTypeInfo(networkType: string): Item | null;
    getNetworkTypeName(networkType: Item): string | null;
    getDownloadTime(size: number, networkType: string): number;
    semverGT(a: string, b: string): boolean;
    semverGTE(a: string, b: string): boolean;
    semverLT(a: string, b: string): boolean;
    semverLTE(a: string, b: string): boolean;
    semverEQ(a: string, b: string): boolean;
    semverDiff(a: string, b: string): string | null;
    semverParse(version?: string): SemVer | null;
    semverSatisfies(version: string | SemVer, range: string | Range): boolean;
    formatDiff(value: DiffItem): string;
    isMatch(a?: string, b?: string | RegExp): boolean;
    exclude<TItem>(items: readonly TItem[], params?: {
        exclude?: (string | RegExp)[] | undefined;
        get?: ((arg: TItem) => string | undefined) | undefined;
    } | undefined): TItem[];
    graph_getNode<TData>(id?: string, graph?: Graph<TData> | undefined): GraphNode<TData> | null;
    graph_getPaths<TData_1>(from?: GraphNode<TData_1> | undefined, graph?: Graph<TData_1> | undefined, to?: GraphNode<TData_1> | undefined, max?: number): PathSolution<TData_1> | null;
    diff_normalizeLimit(limit?: number | Limit | null): Limit | null;
    diff_isLTETheLimit(valueDiff: ValueDiff, limit?: number | Limit | null): boolean;
};
export type Prepared = {
    query: (query: string, data?: unknown, context?: unknown) => unknown;
};
export type Options = {
    helpers?: Record<string, unknown>;
};
export declare function prepareWithJora(input: unknown, options?: Options): Prepared;
