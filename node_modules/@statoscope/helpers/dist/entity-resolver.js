"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIdWrapper = exports.normalizeId = void 0;
function normalizeId(id) {
    return typeof id === 'number' || typeof id === 'bigint' ? String(id) : id;
}
exports.normalizeId = normalizeId;
function getIdWrapper(getId, idModifier) {
    return (entity) => {
        let id = getId(entity);
        if (idModifier) {
            id = idModifier(id);
        }
        return normalizeId(id);
    };
}
exports.getIdWrapper = getIdWrapper;
function warnCache(entities, getId, cache) {
    cache.clear();
    if (Array.isArray(entities) || entities instanceof Set) {
        for (const entity of entities) {
            cache.set(getId(entity), entity);
        }
    }
    else if (entities instanceof Map) {
        for (const [, entity] of entities) {
            cache.set(getId(entity), entity);
        }
    }
    else {
        for (const name in entities) {
            const entity = entities[name];
            cache.set(getId(entity), entity);
        }
    }
}
function makeResolver(entities, getId, get, locked = true) {
    const wrappedGetId = getIdWrapper(getId);
    const cache = new Map();
    warnCache(entities, wrappedGetId, cache);
    const resolver = (id) => {
        const idForCache = normalizeId(id);
        const cached = cache.get(idForCache);
        if (cached) {
            return (get ? get(cached) : cached);
        }
        else if (locked) {
            return null;
        }
        let result = null;
        if (Array.isArray(entities) || entities instanceof Set) {
            for (const entity of entities) {
                if (getId(entity) === id) {
                    result = entity;
                    break;
                }
            }
        }
        else if (entities instanceof Map) {
            for (const [, entity] of entities) {
                if (getId(entity) === id) {
                    result = entity;
                    break;
                }
            }
        }
        else {
            for (const name in entities) {
                const entity = entities[name];
                if (getId(entity) === id) {
                    result = entity;
                    break;
                }
            }
        }
        if (result) {
            cache.set(id, result);
            return (get ? get(result) : result);
        }
        return null;
    };
    resolver.lock = () => {
        warnCache(entities, wrappedGetId, cache);
        locked = true;
    };
    resolver.unlock = () => void (locked = false);
    return resolver;
}
exports.default = makeResolver;
//# sourceMappingURL=entity-resolver.js.map