"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.STATOSCOPE_STAGE_COMPILER_DONE = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const os_1 = require("os");
const open_1 = __importDefault(require("open"));
const json_ext_1 = require("@discoveryjs/json-ext");
const package_json_1 = __importDefault(require("@statoscope/stats/package.json"));
const webpack_stats_extension_compressed_1 = __importDefault(require("@statoscope/webpack-stats-extension-compressed"));
const webpack_stats_extension_package_info_1 = __importDefault(require("@statoscope/webpack-stats-extension-package-info"));
const normalizeCompilation_1 = __importDefault(require("@statoscope/webpack-model/dist/normalizeCompilation"));
const utils_1 = require("@statoscope/report-writer/dist/utils");
const generator_1 = __importDefault(require("@statoscope/stats-extension-custom-reports/dist/generator"));
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { name, version } = require('../package.json');
exports.STATOSCOPE_STAGE_COMPILER_DONE = 5000;
const pluginName = `${name}@${version}`;
class StatoscopeWebpackPlugin {
    constructor(options = {}) {
        var _a, _b;
        var _c;
        this.extensions = [];
        this.options = {
            open: 'file',
            compressor: 'gzip',
            additionalStats: [],
            saveOnlyStats: false,
            watchMode: false,
            reports: [],
            extensions: [],
            ...options,
        };
        if (this.options.saveOnlyStats) {
            this.options.open = false;
        }
        (_a = (_c = this.options).saveReportTo) !== null && _a !== void 0 ? _a : (_c.saveReportTo = this.options.saveTo);
        this.extensions.push(...((_b = this.options.extensions) !== null && _b !== void 0 ? _b : []));
        this.extensions.push(new webpack_stats_extension_package_info_1.default());
        if (this.options.compressor !== false) {
            this.extensions.push(new webpack_stats_extension_compressed_1.default(this.options.compressor));
        }
    }
    interpolate(string, compilation, customName) {
        return string
            .replace(/\[name]/gi, customName || compilation.name || 'unnamed')
            .replace(/\[hash]/gi, compilation.hash || 'unknown');
    }
    apply(compiler) {
        var _a, _b, _c, _d;
        const { options } = this;
        const context = (_d = (_b = (_a = options.statsOptions) === null || _a === void 0 ? void 0 : _a.context) !== null && _b !== void 0 ? _b : 
        // @ts-ignore
        (_c = compiler.options.stats) === null || _c === void 0 ? void 0 : _c.context) !== null && _d !== void 0 ? _d : compiler.context;
        for (const extension of this.extensions) {
            extension.handleCompiler(compiler, context);
        }
        compiler.hooks.done.tapAsync({ stage: exports.STATOSCOPE_STAGE_COMPILER_DONE, name: pluginName }, async (stats, cb) => {
            var _a;
            if (compiler.watchMode && !options.watchMode) {
                return cb();
            }
            // @ts-ignore
            const statsObj = stats.toJson(options.statsOptions || compiler.options.stats);
            statsObj.name = options.name || statsObj.name || stats.compilation.name;
            const statoscopeMeta = {
                descriptor: { name: package_json_1.default.name, version: package_json_1.default.version },
                extensions: [],
                context,
            };
            statsObj.__statoscope = statoscopeMeta;
            for (const extension of this.extensions) {
                statoscopeMeta.extensions.push(extension.getExtension());
            }
            const reports = (_a = this.options.reports) !== null && _a !== void 0 ? _a : [];
            if (reports.length) {
                const generator = new generator_1.default();
                for (const report of reports) {
                    if (typeof report.data === 'function') {
                        report.data = await report.data();
                    }
                    generator.handleReport(report);
                }
                statoscopeMeta.extensions.push(generator.get());
            }
            if (options.normalizeStats) {
                (0, normalizeCompilation_1.default)(statsObj);
            }
            const webpackStatsStream = (0, json_ext_1.stringifyStream)(statsObj, (0, utils_1.makeReplacer)(context, '.', ['context', 'source']));
            let statsFileOutputStream;
            let resolvedSaveStatsTo;
            if (options.saveStatsTo) {
                resolvedSaveStatsTo = path_1.default.resolve(this.interpolate(options.saveStatsTo, stats.compilation, statsObj.name));
                fs_1.default.mkdirSync(path_1.default.dirname(resolvedSaveStatsTo), { recursive: true });
                statsFileOutputStream = fs_1.default.createWriteStream(resolvedSaveStatsTo);
                webpackStatsStream.pipe(statsFileOutputStream);
                await waitStreamEnd(statsFileOutputStream);
            }
            if (!options.normalizeStats) {
                (0, normalizeCompilation_1.default)(statsObj);
            }
            const statsForReport = this.getStatsForHTMLReport({
                filename: resolvedSaveStatsTo,
                stream: (0, json_ext_1.stringifyStream)(statsObj, (0, utils_1.makeReplacer)(context, '.', ['context', 'source'])),
            });
            const htmlReportPath = this.getHTMLReportPath();
            const resolvedHTMLReportPath = path_1.default.resolve(this.interpolate(htmlReportPath, stats.compilation, statsObj.name));
            try {
                await this.makeReport(resolvedHTMLReportPath, statsForReport);
                if (options.open) {
                    if (options.open === 'file') {
                        (0, open_1.default)(resolvedHTMLReportPath);
                    }
                    else {
                        (0, open_1.default)(path_1.default.dirname(resolvedHTMLReportPath));
                    }
                }
                cb();
            }
            catch (e) {
                cb(e);
            }
        });
    }
    getStatsForHTMLReport(mainStats) {
        const mainStatsFilename = mainStats.filename
            ? path_1.default.basename(mainStats.filename)
            : 'stats.json';
        return [
            {
                filename: mainStatsFilename,
                stream: mainStats.stream,
            },
            ...this.options.additionalStats
                .map((statsPath) => {
                const filename = path_1.default.resolve(statsPath);
                return { filename, stream: fs_1.default.createReadStream(filename) };
            })
                .filter(({ filename }) => filename !== mainStatsFilename),
        ];
    }
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types,@typescript-eslint/explicit-function-return-type
    makeReport(outputPath, stats) {
        if (this.options.saveOnlyStats) {
            return { writer: null, stream: null };
        }
        fs_1.default.mkdirSync(path_1.default.dirname(outputPath), { recursive: true });
        return (0, utils_1.transform)({
            writer: {
                scripts: [{ type: 'path', path: require.resolve('@statoscope/webpack-ui') }],
                init: `function (data) {
            Statoscope.default(data.map((item) => ({ name: item.id, data: item.data })));
          }`,
                dataCompression: this.options.disableReportCompression !== true,
            },
        }, stats.map((value) => {
            return {
                type: 'stream',
                filename: value.filename,
                stream: value.stream,
            };
        }), outputPath);
    }
    getHTMLReportPath() {
        const defaultReportName = `statoscope-[name]-[hash].html`;
        if (this.options.saveReportTo) {
            if (this.options.saveReportTo.endsWith('.html')) {
                return this.options.saveReportTo;
            }
            return path_1.default.join(this.options.saveReportTo, defaultReportName);
        }
        return path_1.default.join((0, os_1.tmpdir)(), defaultReportName);
    }
}
exports.default = StatoscopeWebpackPlugin;
async function waitStreamEnd(stream) {
    if (!stream) {
        return;
    }
    return new Promise((resolve, reject) => {
        stream.on('finish', resolve);
        stream.on('error', reject);
    });
}
//# sourceMappingURL=index.js.map