"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const collector_1 = require("./collector");
function handleModule(module, modulesData) {
    var _a, _b, _c, _d;
    let resolvedId = modulesData.idToIxMap.get(module.identifier);
    if (!resolvedId) {
        resolvedId = modulesData.lastId++;
        modulesData.idToIxMap.set(module.identifier, resolvedId);
        modulesData.ixToModuleMap.set(resolvedId, module);
    }
    else {
        const resolvedModule = modulesData.ixToModuleMap.get(resolvedId);
        resolvedModule.chunks = [
            ...new Set([...((_a = resolvedModule.chunks) !== null && _a !== void 0 ? _a : []), ...((_b = module.chunks) !== null && _b !== void 0 ? _b : [])]),
        ];
        const toReasons = (0, collector_1.collectRawReasonsFromArray)((_c = resolvedModule.reasons) !== null && _c !== void 0 ? _c : []);
        const fromReasons = (0, collector_1.collectRawReasonsFromArray)((_d = module.reasons) !== null && _d !== void 0 ? _d : []);
        const reasonMap = new Map();
        for (const current of [...toReasons.values(), ...fromReasons.values()]) {
            const key = `${current.moduleIdentifier}-${current.type}-${current.loc}`;
            if (!reasonMap.has(key)) {
                reasonMap.set(key, current);
            }
        }
        resolvedModule.reasons = [...reasonMap.values()];
    }
    return resolvedId;
}
function handleChunk(chunk, modulesData) {
    var _a;
    const modules = (0, collector_1.collectRawModulesFromArray)((_a = chunk.modules) !== null && _a !== void 0 ? _a : []);
    chunk.modules = [...modules.values()];
    for (const [id, module] of chunk.modules.entries()) {
        // @ts-ignore
        chunk.modules[id] = handleModule(module, modulesData);
    }
}
function handleCompilation(compilation, compilationMap) {
    var _a;
    const modulesData = {
        ixToModuleMap: new Map(),
        idToIxMap: new Map(),
        lastId: 1,
    };
    compilationMap.set((compilation.hash || compilation.name), {
        modules: modulesData,
    });
    const modules = (0, collector_1.collectRawModulesFromArray)((_a = compilation.modules) !== null && _a !== void 0 ? _a : []);
    compilation.modules = [...modules.values()];
    for (const [id, module] of compilation.modules.entries()) {
        // @ts-ignore
        compilation.modules[id] = handleModule(module, modulesData);
    }
    for (const chunk of compilation.chunks || []) {
        handleChunk(chunk, modulesData);
    }
}
function normalizeCompilation(json) {
    var _a;
    // @ts-ignore
    if ((_a = json.__statoscope) === null || _a === void 0 ? void 0 : _a.normalization) {
        return json;
    }
    const compilationMap = new Map();
    const compilations = [json];
    let cursor;
    while ((cursor = compilations.pop())) {
        handleCompilation(cursor, compilationMap);
        for (const child of cursor.children || []) {
            compilations.push(child);
        }
    }
    const normalizationData = {
        links: { modules: ['chunks'] },
        data: {
            compilations: [...compilationMap.entries()].map(([id, compilation]) => {
                return {
                    id,
                    data: {
                        modules: [...compilation.modules.ixToModuleMap.entries()],
                    },
                };
            }),
        },
    };
    // @ts-ignore
    json.__statoscope = json.__statoscope || {};
    // @ts-ignore
    json.__statoscope.normalization = normalizationData;
    return json;
}
exports.default = normalizeCompilation;
//# sourceMappingURL=normalizeCompilation.js.map