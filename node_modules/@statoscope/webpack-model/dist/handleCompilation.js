"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPackages = void 0;
const md5_1 = __importDefault(require("md5"));
const graph_1 = __importDefault(require("@statoscope/helpers/dist/graph"));
const indexer_1 = __importDefault(require("@statoscope/helpers/dist/indexer"));
const module_1 = require("./module");
const collector_1 = require("./collector");
function getHash(compilation, parent) {
    if (compilation.hash) {
        return compilation.hash;
    }
    if (parent) {
        return (0, md5_1.default)(parent.hash + String(compilation.name));
    }
    return (0, md5_1.default)(compilation.name || 'unknown');
}
function handleCompilations(rawStatsFileDescriptor, file, fileContext) {
    const compilations = [];
    const stack = [
        {
            compilation: rawStatsFileDescriptor.data,
            parent: null,
        },
    ];
    let cursor;
    while ((cursor = stack.pop())) {
        const handled = handleCompilation(cursor.compilation, file, cursor.parent, fileContext);
        if (cursor.parent) {
            cursor.parent.children.push(handled.data);
        }
        file.compilations.push(handled.data);
        compilations.push(handled);
        for (const child of cursor.compilation.children || []) {
            stack.push({ compilation: child, parent: handled.data });
        }
    }
    return compilations;
}
exports.default = handleCompilations;
function buildGraph(compilation) {
    var _a;
    const moduleGraph = new graph_1.default();
    const globalHandled = new Set();
    for (const entry of compilation.entrypoints) {
        if ((_a = entry.data.dep) === null || _a === void 0 ? void 0 : _a.module) {
            handleModuleNode(moduleGraph, entry.data.dep.module);
        }
    }
    return {
        module: moduleGraph,
    };
    function handleModuleNode(graph, module) {
        var _a, _b;
        if (globalHandled.has(module)) {
            return graph.getNode(module.identifier);
        }
        globalHandled.add(module);
        const entries = module.reasons
            .filter((r) => r.resolvedEntry)
            .map((r) => r.resolvedEntry);
        const node = (_a = graph.getNode(module.identifier)) !== null && _a !== void 0 ? _a : graph.makeNode(module.identifier, { module, entries });
        const handled = new WeakSet();
        for (const innerModule of module.modules) {
            handled.add(innerModule);
            node.addChild(handleModuleNode(graph, innerModule));
        }
        for (const dep of (_b = module.deps) !== null && _b !== void 0 ? _b : []) {
            if (handled.has(dep.module)) {
                continue;
            }
            handled.add(dep.module);
            node.addChild(handleModuleNode(graph, dep.module));
        }
        return node;
    }
}
function moduleIdModifier(id) {
    let cached = moduleIdModifier.cache.get(id);
    if (!cached) {
        cached = id.replace(/(.+[|\s])([a-f0-9]+)$/, '$1root');
        moduleIdModifier.cache.set(id, cached);
    }
    return cached;
}
moduleIdModifier.cache = new Map();
function handleCompilation(compilation, file, parent, fileContext) {
    const normalized = {
        time: compilation.time,
        builtAt: compilation.builtAt,
        name: compilation.name,
        hash: getHash(compilation, parent),
        entrypoints: [],
        chunks: [],
        assets: [],
        modules: [],
        nodeModules: [],
        children: [],
        isChild: !!(parent === null || parent === void 0 ? void 0 : parent.hash),
        parent: (parent === null || parent === void 0 ? void 0 : parent.hash) || null,
    };
    const indexes = {
        assets: (0, indexer_1.default)((item) => item.name),
        chunks: (0, indexer_1.default)((item) => item.id),
        entrypoints: (0, indexer_1.default)((item) => item.name),
        modules: (0, indexer_1.default)((item) => item.identifier, null, {
            idModifier: moduleIdModifier,
        }),
        packages: (0, indexer_1.default)((item) => item.name),
    };
    const rawIndexes = {
        assets: (0, indexer_1.default)((item) => item.name),
        chunks: (0, indexer_1.default)((item) => item.id),
        entrypoints: (0, indexer_1.default)((item) => item.name),
        modules: (0, indexer_1.default)((item) => item.identifier, null, {
            idModifier: moduleIdModifier,
        }),
    };
    const resolvers = {
        resolveAsset: (id) => indexes.assets.get(id),
        resolveChunk: (id) => indexes.chunks.get(id),
        resolveEntrypoint: (id) => indexes.entrypoints.get(id),
        resolvePackage: (id) => indexes.packages.get(id),
        resolveModule: (id) => indexes.modules.get(id),
    };
    const processingContext = {
        fileContext,
        indexes,
        rawIndexes,
        resolvers,
    };
    for (const module of (0, collector_1.collectRawModules)(compilation)) {
        processingContext.rawIndexes.modules.add(module);
    }
    for (const chunk of (0, collector_1.collectRawChunks)(compilation)) {
        processingContext.rawIndexes.chunks.add(chunk);
    }
    for (const asset of (0, collector_1.collectRawAssets)(compilation)) {
        processingContext.rawIndexes.assets.add(asset);
    }
    for (const entrypoint of (0, collector_1.collectRawEntrypoints)(compilation)) {
        processingContext.rawIndexes.entrypoints.add(entrypoint);
    }
    prepareEntries(compilation, processingContext);
    prepareModules(processingContext);
    prepareChunks(processingContext);
    linkChunks(processingContext);
    prepareAssets(processingContext);
    extractPackages(normalized, processingContext);
    for (const module of processingContext.indexes.modules.getAll()) {
        normalized.modules.push(module);
        processingContext.fileContext.indexes.compilation.byModule.set(module, normalized);
    }
    for (const chunk of processingContext.indexes.chunks.getAll()) {
        normalized.chunks.push(chunk);
        processingContext.fileContext.indexes.compilation.byChunks.set(chunk, normalized);
    }
    for (const asset of processingContext.indexes.assets.getAll()) {
        normalized.assets.push(asset);
        processingContext.fileContext.indexes.compilation.byAsset.set(asset, normalized);
    }
    for (const entry of processingContext.indexes.entrypoints.getAll()) {
        normalized.entrypoints.push(entry);
        processingContext.fileContext.indexes.compilation.byEntrypoint.set(entry, normalized);
    }
    const graph = buildGraph(normalized);
    return {
        data: normalized,
        resolvers,
        indexes: processingContext.indexes,
        graph: {
            module: graph.module,
        },
        file,
    };
}
function mergeModules(from, to, context) {
    var _a, _b, _c;
    const chunks = new Set([...((_a = to.chunks) !== null && _a !== void 0 ? _a : []), ...((_b = from.chunks) !== null && _b !== void 0 ? _b : [])].reduce((acc, c) => {
        const id = typeof c === 'string' || typeof c === 'number' ? c : c.id;
        const chunk = context.rawIndexes.chunks.get(id);
        if (chunk) {
            acc.push(chunk);
        }
        return acc;
    }, []));
    const toReasons = (0, collector_1.collectRawReasonsFromArray)(to.reasons);
    const fromReasons = (0, collector_1.collectRawReasonsFromArray)((_c = from.reasons) !== null && _c !== void 0 ? _c : []);
    const reasonMap = new Map();
    to.chunks = [...chunks];
    for (const current of [...toReasons.values(), ...fromReasons.values()]) {
        const key = `${current.moduleIdentifier}-${current.type}-${current.loc}`;
        if (!reasonMap.has(key)) {
            reasonMap.set(key, current);
        }
    }
    to.reasons = [...reasonMap.values()];
}
function prepareModule(module, context) {
    var _a, _b, _c, _d, _e;
    var _f, _g;
    if (context.indexes.modules.hasId(module.identifier)) {
        return;
    }
    const existingModule = context.indexes.modules.get(module.identifier);
    const normalizedModule = module;
    context.indexes.modules.add(normalizedModule);
    normalizedModule.resolvedResource = (0, module_1.moduleResource)(module);
    if (module.issuerPath) {
        normalizedModule.issuerPath.map((i) => (i.resolvedModule = context.rawIndexes.modules.get(i.identifier)));
    }
    else {
        module.issuerPath = [];
    }
    if (module.chunks) {
        normalizedModule.chunks = module.chunks
            .map((c) => resolveRawChunk(c, context))
            .filter(Boolean);
    }
    else {
        module.chunks = [];
    }
    if (module.reasons) {
        const reasons = (0, collector_1.collectRawReasonsFromArray)(module.reasons);
        let newReasons = [];
        for (const item of reasons.values()) {
            newReasons.push(item);
        }
        newReasons = newReasons.filter((r) => r.moduleIdentifier !== module.identifier);
        for (const reason of newReasons) {
            const normalizedReason = normalizeReason(reason, context);
            const resolvedModule = normalizedReason.resolvedModule;
            const resolvedEntry = normalizedReason.resolvedEntry;
            if (resolvedModule) {
                (_a = resolvedModule.deps) !== null && _a !== void 0 ? _a : (resolvedModule.deps = []);
                resolvedModule.deps.push({
                    type: 'module',
                    module: normalizedModule,
                    reason: normalizedReason,
                });
            }
            if (resolvedEntry) {
                resolvedEntry.data.dep = {
                    type: 'module',
                    module: (_b = normalizedReason.resolvedModule) !== null && _b !== void 0 ? _b : normalizedModule,
                    reason: normalizedReason,
                };
            }
        }
        module.reasons = newReasons;
    }
    else {
        module.reasons = [];
    }
    if (existingModule) {
        mergeModules(module, existingModule, context);
    }
    (_c = (_f = module).modules) !== null && _c !== void 0 ? _c : (_f.modules = []);
    const innerModules = (0, collector_1.collectRawModulesFromArray)(module.modules);
    const newInnerModules = [];
    for (const item of innerModules.values()) {
        const innerModule = context.rawIndexes.modules.get(item.identifier);
        newInnerModules.push(innerModule);
        (_d = innerModule.chunks) !== null && _d !== void 0 ? _d : (innerModule.chunks = []);
        if (!innerModule.chunks.length) {
            innerModule.chunks = module.chunks;
            for (const chunk of module.chunks) {
                (_e = (_g = chunk).modules) !== null && _e !== void 0 ? _e : (_g.modules = []);
                chunk.modules.push(innerModule);
            }
        }
    }
    module.modules = newInnerModules;
}
function normalizeReason(reason, context) {
    var _a;
    const normalizedReason = reason;
    normalizedReason.resolvedModule = reason.moduleIdentifier
        ? context.rawIndexes.modules.get(reason.moduleIdentifier)
        : null;
    if (/(?:.+ )?entry$/.test((_a = reason.type) !== null && _a !== void 0 ? _a : '')) {
        if (reason.loc) {
            let resolvedName = reason.loc;
            let resolved = context.indexes.entrypoints.get(resolvedName);
            if (!resolved) {
                // handle foo[0] for webpack 4 single entry
                resolvedName = reason.loc.slice(0, -3);
                resolved = context.indexes.entrypoints.get(resolvedName);
            }
            if (resolved) {
                normalizedReason.resolvedEntryName = resolvedName;
                normalizedReason.resolvedEntry = resolved;
            }
        }
    }
    return normalizedReason;
}
function prepareModules(context) {
    for (const module of context.rawIndexes.modules.getAll()) {
        prepareModule(module, context);
    }
}
function resolveRawChunk(chunk, context) {
    return context.rawIndexes.chunks.get(typeof chunk === 'string' || typeof chunk === 'number' ? chunk : chunk.id);
}
function prepareChunk(chunk, context) {
    if (chunk == null) {
        return;
    }
    if (context.indexes.chunks.hasId(chunk.id)) {
        return;
    }
    const normalizedChunk = chunk;
    context.indexes.chunks.add(normalizedChunk);
    if (chunk.modules) {
        chunk.modules = [...context.indexes.modules.getAll()].filter((m) => m.chunks.find((c) => c.id === chunk.id));
    }
    else {
        chunk.modules = [];
    }
    if (chunk.files) {
        normalizedChunk.files = chunk.files
            .filter(Boolean) // to skip null files, issue #158
            .map((f) => context.rawIndexes.assets.get(typeof f === 'string' ? f : f.name))
            .filter(Boolean);
    }
    else {
        chunk.files = [];
    }
    if (chunk.sizes) {
        const keys = Object.keys(chunk.sizes);
        if (keys.length === 1 && keys[0] === 'runtime') {
            chunk.isRuntime = true;
        }
    }
    if (chunk.children) {
        chunk.children.forEach((c) => resolveRawChunk(c, context));
        for (const children of chunk.children) {
            prepareChunk(resolveRawChunk(children, context), context);
        }
    }
    chunk.children = [];
    if (chunk.siblings) {
        normalizedChunk.siblings = chunk.siblings
            .map((c) => resolveRawChunk(c, context))
            .filter(Boolean);
        for (const sibling of chunk.siblings) {
            prepareChunk(resolveRawChunk(sibling, context), context);
        }
    }
    else {
        chunk.siblings = [];
    }
    if (chunk.parents) {
        chunk.parents.forEach((c) => resolveRawChunk(c, context));
        for (const parent of chunk.parents) {
            prepareChunk(resolveRawChunk(parent, context), context);
        }
    }
    chunk.parents = [];
    if (chunk.origins) {
        const origins = [...(0, collector_1.collectRawReasonsFromArray)(chunk.origins).values()];
        origins.forEach((o) => {
            var _a;
            if (!o.moduleIdentifier) {
                o.resolvedEntryName = o.loc;
                o.resolvedEntry =
                    (_a = context.indexes.entrypoints.get(o.loc)) !== null && _a !== void 0 ? _a : null;
            }
            o.resolvedModule = o.moduleIdentifier
                ? context.rawIndexes.modules.get(o.moduleIdentifier)
                : null;
        });
        chunk.origins = origins;
    }
    else {
        chunk.origins = [];
    }
}
function prepareChunks(context) {
    for (const chunk of context.rawIndexes.chunks.getAll()) {
        prepareChunk(chunk, context);
    }
}
function getChunkMapItem(map, chunk) {
    let mapItem = map.get(chunk);
    if (!mapItem) {
        mapItem = {
            children: new Set(),
            parents: new Set(),
        };
        map.set(chunk, mapItem);
    }
    return mapItem;
}
function linkChunks(context) {
    var _a, _b, _c, _d;
    const map = new Map();
    top: for (const childChunk of context.indexes.chunks.getAll()) {
        const childMapItem = getChunkMapItem(map, childChunk);
        for (const origin of childChunk.origins) {
            let targetModule = (_a = origin.resolvedModule) !== null && _a !== void 0 ? _a : null;
            if (!targetModule && origin.resolvedEntry) {
                targetModule = (_c = (_b = origin.resolvedEntry.data.dep) === null || _b === void 0 ? void 0 : _b.module) !== null && _c !== void 0 ? _c : null;
            }
            if (targetModule === null || targetModule === void 0 ? void 0 : targetModule.chunks.includes(childChunk)) {
                continue top;
            }
            for (const parentChunk of (_d = targetModule === null || targetModule === void 0 ? void 0 : targetModule.chunks) !== null && _d !== void 0 ? _d : []) {
                const parentMapItem = getChunkMapItem(map, parentChunk);
                if (parentChunk !== childChunk) {
                    parentMapItem.children.add(childChunk);
                    childMapItem.parents.add(parentChunk);
                }
            }
        }
    }
    for (const [chunk, data] of map) {
        chunk.children = [...data.children];
        chunk.parents = [...data.parents];
    }
}
function prepareAssets(context) {
    var _a;
    for (const asset of context.rawIndexes.assets.getAll()) {
        const normalizedAsset = asset;
        context.indexes.assets.add(normalizedAsset);
        if (asset.chunks) {
            asset.chunks = asset.chunks
                .map((c) => resolveRawChunk(c, context))
                .filter(Boolean);
        }
        else {
            asset.chunks = [];
        }
        (_a = asset.files) !== null && _a !== void 0 ? _a : (asset.files = []);
    }
}
function prepareEntries(compilation, context) {
    for (const name in compilation.entrypoints) {
        const entry = compilation.entrypoints[name];
        if (entry.chunks) {
            entry.chunks = entry.chunks
                .map((c) => resolveRawChunk(c, context))
                .filter(Boolean);
        }
        if (entry.assets) {
            entry.assets = entry.assets
                .map((a) => context.rawIndexes.assets.get(typeof a === 'string' ? a : a.name))
                .filter(Boolean);
        }
        context.indexes.entrypoints.add({ name, data: entry });
    }
}
function extractPackages(compilation, context) {
    const extractModulePackages = (module) => {
        var _a, _b;
        const resource = (0, module_1.moduleResource)(module);
        if (!resource) {
            return;
        }
        const modulePackage = (0, module_1.nodeModule)(resource);
        if (modulePackage) {
            let resolvedPackage = context.indexes.packages.get(modulePackage.name);
            if (!resolvedPackage) {
                resolvedPackage = { name: modulePackage.name, instances: [] };
                context.indexes.packages.add(resolvedPackage);
            }
            let instance = resolvedPackage.instances.find(({ path }) => path === modulePackage.path);
            if (!instance) {
                const packageInfoExt = context.fileContext.resolvers.resolveExtension('@statoscope/stats-extension-package-info');
                const api = packageInfoExt === null || packageInfoExt === void 0 ? void 0 : packageInfoExt.api;
                const extInstance = (_a = api === null || api === void 0 ? void 0 : api.getInstance(compilation.hash, resolvedPackage.name, modulePackage.path)) !== null && _a !== void 0 ? _a : null;
                instance = {
                    path: modulePackage.path,
                    isRoot: modulePackage.isRoot,
                    reasons: [],
                    modules: [module],
                    version: extInstance === null || extInstance === void 0 ? void 0 : extInstance.info.version,
                };
                resolvedPackage.instances.push(instance);
            }
            else {
                if (!instance.modules.includes(module)) {
                    instance.modules.push(module);
                }
            }
            const instanceReasonsKeys = new Set(instance.reasons.map((r) => r.data.identifier));
            // reasons already ungrouped and normalized
            const reasons = module.reasons;
            for (const reason of reasons !== null && reasons !== void 0 ? reasons : []) {
                const reasonPackage = (0, module_1.nodeModule)((0, module_1.moduleReasonResource)(reason));
                if (reasonPackage && reasonPackage.path === instance.path) {
                    continue;
                }
                const reasonType = 'module';
                const reasonKey = (_b = reason.moduleIdentifier) !== null && _b !== void 0 ? _b : 'unknown';
                if (!instanceReasonsKeys.has(reasonKey) && reason.resolvedModule) {
                    instance.reasons.push({
                        type: reasonType,
                        data: reason.resolvedModule,
                    });
                    instanceReasonsKeys.add(reasonKey);
                }
            }
        }
    };
    for (const module of context.rawIndexes.modules.getAll()) {
        extractModulePackages(module);
    }
    for (const packageItem of context.indexes.packages.getAll()) {
        compilation.nodeModules.push(packageItem);
    }
}
exports.extractPackages = extractPackages;
//# sourceMappingURL=handleCompilation.js.map