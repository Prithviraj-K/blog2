{
  "version": 3,
  "sources": ["../src/index.js"],
  "sourcesContent": ["const TYPE_EOF   = 0b0000;\nconst TYPE_WS    = 0b0001;\nconst TYPE_DELIM = 0b0010;\nconst TYPE_NUM   = 0b0100;\nconst TYPE_WORD  = 0b1000;\nconst TYPE_WS_OR_DELIM = TYPE_WS | TYPE_DELIM;\nconst TYPE_NUM_OR_WORD = TYPE_NUM | TYPE_WORD;\nconst DEBUG = false;\nconst DEBUG_TYPE_NAME = {\n    [TYPE_EOF]: 'eof',\n    [TYPE_WS]: 'ws',\n    [TYPE_DELIM]: 'delim',\n    [TYPE_NUM]: 'number',\n    [TYPE_WORD]: 'word'\n};\n\nconst isSortableValue = value => typeof value === 'number' || typeof value === 'string';\nconst safeCharCodeAt = (source, offset) => offset < source.length ? source.charCodeAt(offset) : 0;\nconst isSign = (code) => code === 0x002B || code === 0x002D; // + or -\nconst isDigit = (code) => code >= 0x0030 && code <= 0x0039;\nconst isWS = (code) => (\n    code === 0x0009 ||  // \\t\n    code === 0x000A ||  // \\n\n    code === 0x000C ||  // \\f\n    code === 0x000D ||  // \\r\n    code === 0x0020     // whitespace\n);\nconst isDelim = (code) => (\n    (code > 0x0020 && code < 0x0100) &&  // ascii char\n    (code < 0x0041 || code > 0x005A) &&  // not A..Z\n    (code < 0x0061 || code > 0x007A) &&  // not a..z\n    !isDigit(code) &&                    // not 0..9\n    !isSign(code)                        // not + or -\n) || code === 0x2116;  /* \u2116 */\nconst isWord = (code) => (\n    code &&\n    !isWS(code) &&\n    !isDelim(code) &&\n    !isDigit(code)\n);\n\n//  Check if three code points would start a number\nconst isNumberStart = (first, second, third) => {\n    // Look at the first code point:\n\n    // U+002B PLUS SIGN (+)\n    // U+002D HYPHEN-MINUS (-)\n    if (isSign(first)) {\n        // If the second code point is a digit, return true.\n        if (isDigit(second)) {\n            return 2;\n        }\n\n        // Otherwise, if the second code point is a U+002E FULL STOP (.)\n        // and the third code point is a digit, return true.\n        // Otherwise, return false.\n        return second === 0x002E && isDigit(third) ? 3 : 0;\n    }\n\n    // U+002E FULL STOP (.)\n    // if (first === 0x002E) {\n    //     // If the second code point is a digit, return true. Otherwise, return false.\n    //     return isDigit(second) ? 2 : 0;\n    // }\n\n    // digit\n    if (isDigit(first)) {\n        // Return true.\n        return 1;\n    }\n\n    // anything else\n    // Return false.\n    return 0;\n};\n\nconst findEndOfType = (source, offset, isType) => {\n    while (isType(safeCharCodeAt(source, ++offset))) {\n        // do nothing\n    }\n\n    return offset;\n};\n\nconst consumeNumber = (source, offset, preventFloat) => {\n    let code = safeCharCodeAt(source, offset);\n\n    // If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (isSign(code)) {\n        code = safeCharCodeAt(source, offset += 1);\n    }\n\n    // While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findEndOfType(source, offset, isDigit);\n        code = safeCharCodeAt(source, offset);\n    }\n\n    // If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(safeCharCodeAt(source, offset + 1))) {\n        if (preventFloat) {\n            return offset;\n        }\n\n        // Consume them\n        // While the next input code point is a digit, consume it and append it to repr.\n        const expectedEnd = findEndOfType(source, offset + 1, isDigit);\n        code = safeCharCodeAt(source, expectedEnd);\n\n        // If next char is U+002E FULL STOP (.), then don't consume\n        if (code === 0x002E) {\n            return offset;\n        }\n\n        offset = expectedEnd;\n    }\n\n    // If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (code === 0x0045 /* e */ || code === 0x0065 /* E */) {\n        let sign = 1;\n        code = safeCharCodeAt(source, offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (isSign(code)) {\n            sign = 2;\n            code = safeCharCodeAt(source, offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // While the next input code point is a digit, consume it and append it to repr.\n            offset = findEndOfType(source, offset + sign, isDigit);\n        }\n    }\n\n    return offset;\n};\n\nconst getToken = (source, offset, preventFloat, preventSign) => {\n    if (offset >= source.length) {\n        return TYPE_EOF;\n    }\n\n    const code = safeCharCodeAt(source, offset);\n\n    // Whitespace\n    if (isWS(code)) {\n        return TYPE_WS | (findEndOfType(source, offset, isWS) - offset << 4);\n    }\n\n    // Delim sequence\n    // console.log(source[offset], isDelim(a), a.toString(16), preventSign)\n    if (isDelim(code) || (preventSign && isSign(code))) {\n        return TYPE_DELIM | (findEndOfType(source, offset, isDelim) - offset << 4);\n    }\n\n    // Number\n    if (isNumberStart(code, safeCharCodeAt(source, offset + 1), safeCharCodeAt(source, offset + 2))) {\n        return TYPE_NUM | (consumeNumber(source, offset, preventFloat) - offset << 4);\n    }\n\n    // Word\n    return TYPE_WORD | (findEndOfType(source, offset, isWord) - offset << 4);\n};\n\nconst compare = (a, b, analytical) => {\n    let offsetA = 0;\n    let offsetB = 0;\n    let preventFloat = false;\n    let preventSign = false;\n    let postCmpResult = 0;\n    let postCmpResultType = 0;\n    let firstPart = true;\n\n    while (true) {\n        const partA = getToken(a, offsetA, preventFloat, preventSign);\n        const partB = getToken(b, offsetB, preventFloat, preventSign);\n        const typeA = partA & 15;\n        const lenA = partA >> 4;\n        const typeB = partB & 15;\n        const lenB = partB >> 4;\n\n        /* c8 ignore next 6 */\n        if (DEBUG) {\n            console.log({\n                typeA: DEBUG_TYPE_NAME[typeA], lenA, substrA: a.substr(offsetA, lenA),\n                typeB: DEBUG_TYPE_NAME[typeB], lenB, substrB: b.substr(offsetB, lenB)\n            });\n        }\n\n        if (typeA !== typeB) {\n            if (firstPart && (typeA & TYPE_WS_OR_DELIM) && (typeB & TYPE_NUM_OR_WORD)) {\n                postCmpResult = 1;\n                postCmpResultType = typeA;\n                offsetA += lenA;\n                continue;\n            }\n\n            if (firstPart && (typeB & TYPE_WS_OR_DELIM) && (typeA & TYPE_NUM_OR_WORD)) {\n                postCmpResult = -1;\n                postCmpResultType = typeB;\n                offsetB += lenB;\n                continue;\n            }\n\n            return typeA - typeB;\n        }\n\n        // both parts are the same type, no matter which type to test\n        if (typeA === TYPE_EOF) {\n            return postCmpResult;\n        }\n\n        // reset flags\n        firstPart = false;\n        preventFloat = false;\n        preventSign = false;\n\n        // find difference in substr\n        const minLength = lenA < lenB ? lenA : lenB;\n        let substrDiff = lenA - lenB;\n        let cA = '';\n        let cB = '';\n        for (let i = 0; i < minLength; i++) {\n            cA = a[offsetA + i];\n            cB = b[offsetB + i];\n\n            if (cA !== cB) {\n                substrDiff = cA < cB ? -1 : 1;\n                break;\n            }\n        }\n\n        // both parts are the same type, no matter which type to test\n        if (typeA & TYPE_WS_OR_DELIM) {\n            preventFloat = a[offsetA + lenA - 1] === '.';\n\n            if (substrDiff !== 0) {\n                if (typeA > postCmpResultType) {\n                    postCmpResultType = typeA;\n                    postCmpResult = substrDiff;\n                }\n            }\n        } else if (typeA & TYPE_NUM) {\n            preventSign = true;\n\n            if (substrDiff !== 0) {\n                const numDiff = a.substr(offsetA, lenA) - b.substr(offsetB, lenB);\n\n                if (numDiff !== 0) {\n                    return analytical ? -numDiff : numDiff;\n                }\n\n                if (typeA > postCmpResultType) {\n                    const afc = safeCharCodeAt(a, offsetA);\n                    const bfc = safeCharCodeAt(b, offsetB);\n                    const order = afc === 0x002D ? -1 : 1;\n\n                    // a/b  -  o  +\n                    //   -  0 -1 -1\n                    //   o  1  0 -1\n                    //   +  1  1  0\n\n                    postCmpResultType = typeA;\n                    postCmpResult = afc !== bfc && (afc === 0x002D /* - */ || bfc === 0x002B /* + */)\n                        ? -1\n                        : afc !== bfc && (afc === 0x002B /* + */ || bfc === 0x002D /* - */)\n                            ? 1\n                            : (lenA - lenB || substrDiff) < 0 // lenA !== lenB ? lenA < lenB : substrDiff < 0\n                                ? -order\n                                : order;\n\n                    if (analytical) {\n                        postCmpResult = -postCmpResult;\n                    }\n                }\n            }\n        } else { // typeA === TYPE_WORD\n            if (substrDiff !== 0) {\n                if (cA !== cB) {\n                    // case insensitive checking\n                    const sA = a.substr(offsetA, lenA);\n                    const sB = b.substr(offsetB, lenB);\n                    const siA = sA.toLowerCase();\n                    const siB = sB.toLowerCase();\n\n                    if (siA !== siB) {\n                        return siA < siB ? -1 : 1;\n                    }\n\n                    return sA < sB ? -1 : 1;\n                }\n\n                return substrDiff;\n            }\n        }\n\n        offsetA += lenA;\n        offsetB += lenB;\n    }\n};\n\nconst createCompareFn = analytical => (a, b) => {\n    /* c8 ignore next */\n    DEBUG && console.log('Compare', a, b);\n\n    if (isSortableValue(a) && isSortableValue(b)) {\n        const ret = Math.sign(compare(String(a), String(b), analytical));\n\n        /* c8 ignore next */\n        DEBUG && console.log('Result:', ret);\n\n        return ret;\n    }\n\n    /* c8 ignore next */\n    DEBUG && console.log('Result: (non-comparable)');\n\n    return 0;\n};\n\nexport const naturalCompare = createCompareFn(false);\nexport const naturalAnalyticalCompare = createCompareFn(true);\n"],
  "mappings": "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",
  "names": ["isSortableValue", "value", "safeCharCodeAt", "source", "offset", "isSign", "code", "isDigit", "isWS", "isDelim", "isWord", "isNumberStart", "first", "second", "third", "findEndOfType", "isType", "consumeNumber", "preventFloat", "expectedEnd", "sign", "getToken", "preventSign", "compare", "a", "b", "analytical", "offsetA", "offsetB", "postCmpResult", "postCmpResultType", "firstPart", "partA", "partB", "typeA", "lenA", "typeB", "lenB", "minLength", "substrDiff", "cA", "cB", "i", "numDiff", "afc", "bfc", "order", "sA", "sB", "siA", "siB", "createCompareFn", "naturalCompare", "naturalAnalyticalCompare"]
}
